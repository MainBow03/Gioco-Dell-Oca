<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiverse Run: Arcade</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @keyframes bounce-slow {
            0%, 100% { transform: translateY(-5%); }
            50% { transform: translateY(5%); }
        }
        .animate-bounce-slow {
            animation: bounce-slow 2s infinite;
        }
        .gem-glow {
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
        }
        .black-hole-bg {
            background: repeating-linear-gradient(
                45deg,
                #000,
                #000 10px,
                #1e1b4b 10px,
                #1e1b4b 20px
            );
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Dice5, LogOut, ArrowRight, Skull, RefreshCcw, 
            ArrowUp, ArrowDown, Footprints, Crown, Trophy, 
            Zap, Bomb, Flag, Flame, Ghost, ShieldAlert, Pointer, Dices, Info, Medal, User, X, ChevronsUp, Users, Shield, AlertCircle, Shuffle, Gem, Biohazard, ArrowLeft, Swords,
            Gavel, ArrowLeftRight, Sparkles, Ban, MousePointer2, Target, Heart, Crosshair, Disc, Bot, Move
        } from 'lucide-react';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken,
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            arrayUnion 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyDTaGJcSOVHg3_2K5SgcrDfANtdn0ewb6s",
            authDomain: "gioco-oca-pincher.firebaseapp.com",
            projectId: "gioco-oca-pincher",
            storageBucket: "gioco-oca-pincher.firebasestorage.app",
            messagingSenderId: "41567402648",
            appId: "1:41567402648:web:292e0567e58e814276aeed",
            measurementId: "G-RCF5K88KPN"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const appId = 'multiverse_goose_game_v2'; 

        const TEAM_COLORS = [
            { name: "Rosso", bg: "bg-red-500", border: "border-red-500", text: "text-red-500", light: "bg-red-50", ring: "ring-red-500" },
            { name: "Blu", bg: "bg-blue-500", border: "border-blue-500", text: "text-blue-500", light: "bg-blue-50", ring: "ring-blue-500" },
            { name: "Verde", bg: "bg-green-500", border: "border-green-500", text: "text-green-500", light: "bg-green-50", ring: "ring-green-500" },
            { name: "Giallo", bg: "bg-yellow-500", border: "border-yellow-500", text: "text-yellow-600", light: "bg-yellow-50", ring: "ring-yellow-500" }
        ];

        const ROSTER = [
        { name: "Marinette", img: "https://i.pinimg.com/736x/b8/74/55/b87455575cd069609007a639c9490293.jpg", dice: { name: "Dado Fortunato", vals: [0, 2, 2, 4, 4, 5], color: "bg-pink-500", text: "text-pink-500", desc: "Niente rischi, solo progressi costanti." } },
        { name: "Adrien", img: "https://i.pinimg.com/1200x/5c/2d/c7/5c2dc740ed2fe906b6afaf1320bf4273.jpg", dice: { name: "Dado Cataclisma", vals: [-2, -1, 3, 3, 6, 9], color: "bg-gray-800", text: "text-gray-800", desc: "Estremi pericolosi: o voli o crolli." } },
        { name: "Re Julien", img: "https://i.pinimg.com/736x/1e/17/19/1e17194ef5b383e4202fbb4875cfbd81.jpg", dice: { name: "Dado da Re", vals: [2, 2, 2, 2, 2, 3], color: "bg-yellow-500", text: "text-yellow-500", desc: "Un re non corre, incede con grazia." } },
        { name: "Gwen", img: "https://i.pinimg.com/1200x/59/d7/15/59d71578cd5f889ae898bbc83dda29dc.jpg", dice: { name: "Dado Solitario", vals: [3, 3, 3, 3, 3, 3], color: "bg-teal-600", text: "text-teal-600", desc: "La coerenza è la chiave della vittoria." } },
        { name: "Heather", img: "https://i.pinimg.com/736x/81/5b/b6/815bb632721e7d38f26d35801466dd30.jpg", dice: { name: "Dado Villain", vals: [-1, 1, 2, 2, 6, 8], color: "bg-purple-800", text: "text-purple-800", desc: "Pianifica, indietreggia, colpisci duro." } },
        { name: "Lindsay", img: "https://i.pinimg.com/1200x/ed/96/df/ed96df179eaa7030663473c575067cb4.jpg", dice: { name: "Dado Stupido", vals: [-6, 0, 0, 2, 10, 10], color: "bg-orange-300", text: "text-orange-500", desc: "O disastro totale o miracolo assoluto." } },
        { name: "Yoshi", img: "https://i.pinimg.com/736x/f3/05/7f/f3057f14de68b0afe682ffe93dcc479b.jpg", dice: { name: "Dado Uovo", vals: [2, 2, 2, 3, 3, 3], color: "bg-green-500", text: "text-green-500", desc: "Piccoli saltelli felici verso la meta." } },
        { name: "Wario", img: "https://i.pinimg.com/736x/2f/ea/be/2feabe47151fd436fbf358c299eb4870.jpg", dice: { name: "Dado WAH?", vals: [0, 0, 1, 2, 7, 8], color: "bg-yellow-600", text: "text-yellow-700", desc: "Pigrizia o avidità, niente vie di mezzo." } },
        { name: "Tanjiro", img: "https://i.pinimg.com/736x/e9/6d/20/e96d20e7c159897a05c6baa57fac7f35.jpg", dice: { name: "Dado d'Acqua", vals: [0, 1, 2, 5, 6, 7], color: "bg-cyan-500", text: "text-cyan-600", desc: "Fluido come l'acqua, a volte calmo a volte impetuoso." } },
        { name: "Mr Krab", img: "https://i.pinimg.com/1200x/74/9c/f5/749cf53dd48dbb440fcde8d958c7dbb1.jpg", dice: { name: "Dado Greedy", vals: [-2, -2, 1, 1, 8, 8], color: "bg-red-600", text: "text-red-600", desc: "Rischia tutto per il malloppo grosso." } },
        { name: "Gumball", img: "https://i.pinimg.com/736x/ae/88/e3/ae88e329120b3edc196af1ebbfd8fe07.jpg", dice: { name: "Dado Caotico", vals: [0, 0, 3, 3, 3, 6], color: "bg-blue-400", text: "text-blue-500", desc: "Un disastro controllato." } },
        { name: "Johnny Bravo", img: "https://i.pinimg.com/736x/4a/62/70/4a6270678f7adcf130672bcd0af41fdf.jpg", dice: { name: "Dado Oh Yeah", vals: [0, 0, 1, 6, 7, 8], color: "bg-black", text: "text-black", desc: "Fatti bello e spera nel meglio." } },
        { name: "Steven", img: "https://i.pinimg.com/736x/2b/fd/20/2bfd202ab782611ea6a0fb0cdcdc37ab.jpg", dice: { name: "Dado Diamantato", vals: [1, 1, 1, 1, 2, 3], color: "bg-pink-300", text: "text-pink-400", desc: "Lento e protettivo, ma sicuro." } },
        { name: "Ariana Grande", img: "https://media.tenor.com/1u94p6qR01gAAAAM/ariana-grande-eternal-sunshine.gif", dice: { name: "Dado YUH", vals: [0, 0, 1, 5, 6, 8], color: "bg-indigo-300", text: "text-indigo-400", desc: "Note alte e passi lunghi (se canti)." } },
        { name: "Will", img: "https://i.pinimg.com/originals/88/80/73/8880736b5695844044e0e38c8063a1ff.gif", dice: { name: "Dado Rainbow", vals: [3, 3, 3, 3, 3, 6], color: "bg-indigo-500", text: "text-indigo-500", desc: "Costante con un tocco di favolosità." } },
        { name: "Carlos Oliveira", img: "https://i.pinimg.com/originals/32/0d/d1/320dd13031f1aba8a2d3d9b9837174f4.gif", dice: { name: "Dado Peloso", vals: [-2, 0, 2, 4, 6, 8], color: "bg-orange-800", text: "text-orange-800", desc: "Selvaggio e imprevedibile." } },
        { name: "Leon", img: "https://i.pinimg.com/736x/db/ef/fc/dbeffc6e915a929f7dbe908390f5af42.jpg", dice: { name: "Dado Carismatico", vals: [2, 2, 2, 5, 5, 5], color: "bg-blue-800", text: "text-blue-800", desc: "Solo numeri stilosi." } },
        { name: "Finn", img: "https://i.pinimg.com/736x/7e/0b/c9/7e0bc9826a7652264f32a44bc8a40ede.jpg", dice: { name: "Dado Cauto", vals: [1, 1, 1, 1, 1, 9], color: "bg-blue-300", text: "text-blue-400", desc: "Un passo alla volta, eroe." } },
        { name: "Jake", img: "https://i.pinimg.com/1200x/cd/77/22/cd7722b2f98ffc75d1128913df6861d7.jpg", dice: { name: "Dado Rischioso", vals: [-3, -2, -1, 7, 9, 10], color: "bg-yellow-400", text: "text-yellow-600", desc: "Allungati troppo e torni indietro." } },
        { name: "Stewie", img: "https://i.pinimg.com/1200x/1e/a2/cc/1ea2cc7a197e3841086f4a1ce18b089c.jpg", dice: { name: "Genio del Male", vals: [1, 3, 5, 6, 7, 7], color: "bg-red-500", text: "text-red-500", desc: "Piani complessi per grandi risultati." } },
        { name: "Peter", img: "https://i.pinimg.com/736x/9e/40/74/9e4074bbe7890cd245b51b9ff5c0e33c.jpg", dice: { name: "Dado Affamato", vals: [1, 2, 2, 2, 7, 8], color: "bg-green-600", text: "text-green-700", desc: "Corri verso il buffet." } },
        { name: "Ashley", img: "https://i.pinimg.com/736x/d1/c5/5f/d1c55f57218baecf0c2e160155e80c61.jpg", dice: { name: "Dado Ti Amo", vals: [3, 3, 3, 3, 3, 3], color: "bg-red-400", text: "text-red-400", desc: "Amore costante e ripetitivo." } },
        { name: "Nicole", img: "https://i.pinimg.com/736x/81/24/e4/8124e43da43e1d06dcdbca15f22a0cd9.jpg", dice: { name: "Dado Materno", vals: [0, 0, 2, 5, 5, 5], color: "bg-blue-500", text: "text-blue-600", desc: "Severa ma giusta." } },
        { name: "Lapis", img: "https://i.pinimg.com/1200x/09/fb/12/09fb12467957da96913fc8f75e6f6356.jpg", dice: { name: "Dado Tsunami", vals: [-4, -2, 0, 6, 8, 10], color: "bg-blue-600", text: "text-blue-600", desc: "La forza dell'oceano: devastante o ritirata." } },
        { name: "Jake (DC)", img: "https://i.pinimg.com/736x/bc/a0/76/bca0765eaa0f1e88b0070a5b92c22de7.jpg", dice: { name: "Dado Twink", vals: [-1, 0, 1, 4, 9, 9], color: "bg-pink-400", text: "text-pink-500", desc: "Delicato ma capace di esplodere." } },
        { name: "Tom", img: "https://i.pinimg.com/736x/fb/da/0a/fbda0a5f373f173a17726271e423f953.jpg", dice: { name: "Dado Spia", vals: [1, 2, 4, 4, 6, 7], color: "bg-slate-700", text: "text-slate-700", desc: "Calcolato, preciso e letale." } },
        { name: "Gabby", img: "https://i.pinimg.com/736x/a2/14/9c/a2149c917938c8460be43aca06945173.jpg", dice: { name: "Dado Schizo", vals: [-3, -2, 4, 4, 4, 5], color: "bg-purple-500", text: "text-purple-600", desc: "Caos totale: retromarcia o scatto." } },
        { name: "Po", img: "https://i.pinimg.com/1200x/fb/99/a5/fb99a5c7ce5b313ed1c4e71ee0260a9b.jpg", dice: { name: "Dado Guerriero", vals: [1, 2, 5, 7], color: "bg-red-600", text: "text-red-700", desc: "La via del guerriero è essenziale." } }
        ].map((c, i) => ({ ...c, id: i }));

        const BOSS_DICE_VALS = [3, 4, 5, 6, 7, 8];

        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                const now = ctx.currentTime;
                if (type === 'click') { osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'step') { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'gem') { osc.type = 'sine'; osc.frequency.setValueAtTime(1000, now); osc.frequency.linearRampToValueAtTime(2000, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'zombie') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5); gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'teleport') { osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.2); osc.frequency.exponentialRampToValueAtTime(100, now + 0.4); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.4); osc.start(now); osc.stop(now + 0.4); }
                else if (type === 'punch') { osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.1); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'curse') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'fire') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.3); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'boss_hit') { osc.type = 'square'; osc.frequency.setValueAtTime(80, now); gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 0.2); osc.start(now); osc.stop(now + 0.2); }
                else if (type === 'suck') { osc.type = 'sine'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(0, now + 1); gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 1); osc.start(now); osc.stop(now + 1); }
            } catch (e) { console.error(e); }
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const IconMap = {
            Zap: <Zap />,
            ArrowUp: <ArrowUp />,
            ArrowDown: <ArrowDown />,
            ChevronsUp: <ChevronsUp />,
            Footprints: <Footprints />,
            Shuffle: <Shuffle />,
            Bomb: <Bomb />,
            RefreshCcw: <RefreshCcw />,
            ShieldAlert: <ShieldAlert />,
            Skull: <Skull />,
            ArrowRight: <ArrowRight />,
            Gavel: <Gavel />,
            ArrowLeftRight: <ArrowLeftRight />
        };

        const getIcon = (icon) => {
            if (typeof icon === 'string') return IconMap[icon] || <Info />;
            return icon;
        };

        const CLASSIC_MAP = {
        max: 60,
        specials: {
            6: { type: 'JUMP', val: 12, name: 'Ponte', icon: <ArrowRight />, desc: "Attraversa il ponte! Vai direttamente alla casella 12." },
            16: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            19: { type: 'WAIT', turns: 2, name: 'Pozzo', icon: <RefreshCcw />, desc: "Sei caduto nel Pozzo! Devi aspettare 2 turni per risalire." }, 
            22: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            25: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti subito dietro al giocatore che ti precede in classifica." },
            28: { type: 'SWITCH', name: 'Switch', icon: <ArrowLeftRight />, desc: "Caos! Scambi la posizione con un giocatore a caso." },
            31: { type: 'WAIT', turns: 2, name: 'Pozzo 2', icon: <RefreshCcw />, desc: "Un altro pozzo! Aspetta 2 turni." },
            42: { type: 'BACK', val: 30, name: 'Labirinto', icon: <ArrowDown />, desc: "Ti sei perso nel Labirinto! Torni indietro alla casella 30." },
            44: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            48: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            52: { type: 'WAIT', turns: 2, name: 'Prigione', icon: <ShieldAlert />, desc: "Sei stato arrestato! Rimani in Prigione per 2 turni." },
            58: { type: 'RESTART', name: 'Scheletro', icon: <Skull />, desc: "Lo Scheletro ti ha spaventato! Torni all'inizio (START)." },
            5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            9: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            11: { type: 'BOOST', val: 4, name: '+4', icon: <Zap />, desc: "Turbo! Vola avanti di 4 caselle." },
            14: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            23: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            27: { type: 'BOOST', val: -1, name: '-1', icon: <ArrowDown />, desc: "Vento contrario! Torni indietro di 1 casella." },
            36: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            38: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" },
            40: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Strategia! Ti teletrasporti subito dietro al giocatore che ti precede." },
            45: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Volata finale! +3 caselle." },
            50: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            54: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            56: { type: 'BOOST', val: -3, name: '-3', icon: <ArrowDown />, desc: "No! Sei quasi alla fine ma scivoli indietro di 3!" },
        }
        };

        const ELIM_MAP = {
        max: 34,
        specials: {
            3: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint iniziale! +3 caselle." },
            7: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! +3 caselle." },
            8: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" }, 
            10: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino!" },
            12: { type: 'BACK', val: 5, name: 'Trappola', icon: <Bomb />, desc: "È una trappola! Torni alla casella 5." },
            14: { type: 'SWITCH', name: 'Switch', icon: <ArrowLeftRight />, desc: "Caos! Scambi la posizione con un giocatore a caso." },
            15: { type: 'BOOST', val: 4, name: '+4', icon: <Zap />, desc: "Mega Sprint! Corri avanti di 4 caselle." },
            17: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti dietro al giocatore davanti a te." },
            20: { type: 'BACK', val: 10, name: 'Labirinto', icon: <ArrowDown />, desc: "Labirinto insidioso! Torni alla casella 10." }, 
            22: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            25: { type: 'BACK', val: 18, name: 'Tornado', icon: <ArrowDown />, desc: "Un tornado ti spazza via! Torni alla 18." },
            26: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            32: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Sei quasi alla fine ma scivoli! Indietro di 2." },
        }
        };

        const GEM_MAP = {
            max: 50,
            specials: {
                5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                12: { type: 'BOOST', val: 1, name: '+1', icon: <ArrowUp />, desc: "Avanza di 1" },
                18: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                22: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" },
                30: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                38: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                45: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" }
            }
        };

        const DECISION_POOL = [
            { id: 'all_1_me_3', name: 'Leadership', desc: "Tutti avanzano di 1, tu di 3.", icon: <Users/> },
            { id: 'target_back_4', name: 'Sabotaggio', desc: "Scegli chi arretra di 4 caselle.", icon: <ArrowDown/> },
            { id: 'teleport', name: 'Portale', desc: "Ti teletrasporti da un giocatore a caso.", icon: <Shuffle/> },
            { id: 'curse', name: 'Maledizione', desc: "Scegli chi userà il dado maledetto (2,1,0,-1).", icon: <Ban/> },
            { id: 'reroll', name: 'Seconda Chance', desc: "Rilancia subito il dado.", icon: <RefreshCcw/> },
            { id: 'turbo', name: 'Turbo', desc: "Avanza di 4 caselle.", icon: <Zap/> }
        ];

        const PlayerAvatar = ({ charId, size = "md", border = true }) => {
        const s = size === 'sm' ? 'w-8 h-8' : size === 'lg' ? 'w-16 h-16' : 'w-10 h-10';
        const safeCharId = (charId >= 0 && charId < ROSTER.length) ? charId : 0;
        return (
            <img src={ROSTER[safeCharId].img} className={`${s} rounded-full object-cover ${border ? 'border-2 border-white shadow-sm' : ''}`} alt="Avatar" />
        );
        };

        const BoardCell = ({ num, players, special, isElimination, isPendingTarget, onCellClick, onInfoClick, gems, infected, isTargetSelection, lavaTiles, blackHolePos, bossTargetUid }) => {
            let bgClass = "bg-slate-100";
            let borderClass = "border-slate-300";
            let cursorClass = "cursor-pointer"; 
            let highlightClass = "";
            const hasGem = gems && gems.includes(num);
            const isLava = lavaTiles && lavaTiles.includes(num);
            const isBlackHole = blackHolePos !== undefined && num <= blackHolePos;

            if (num === 0) { bgClass = "bg-green-200"; borderClass = "border-green-400"; }
            else if (num === (isElimination ? 34 : (special && !special.max ? 60 : 50))) { bgClass = "bg-yellow-200"; borderClass = "border-yellow-400"; }
            else if (special) {
                if (special.type === 'BOOST' && special.val > 0 || special.type === 'JUMP' || special.type === 'DOUBLE') { bgClass = "bg-cyan-100"; borderClass = "border-cyan-300"; }
                else if ((special.type === 'BOOST' && special.val < 0) || special.type === 'BACK' || special.type === 'RESTART') { bgClass = "bg-red-100"; borderClass = "border-red-300"; }
                else if (special.type === 'WAIT') { bgClass = "bg-slate-300"; borderClass = "border-slate-500"; }
                else if (special.type === 'TAIL' || special.type === 'TELEPORT' || special.type === 'SWITCH') { bgClass = "bg-purple-200"; borderClass = "border-purple-400"; }
                else if (special.type === 'DECISION') { bgClass = "bg-amber-100"; borderClass = "border-amber-400"; }
            }

            if (isLava) { bgClass = "bg-orange-500 animate-pulse ring-2 ring-red-600"; borderClass = "border-red-600"; }
            if (isBlackHole) { bgClass = "black-hole-bg text-white border-black"; borderClass = "border-slate-900"; }
            if (hasGem) { bgClass = "bg-indigo-900"; borderClass = "border-yellow-400"; }
            if (isPendingTarget) { highlightClass = "ring-4 ring-yellow-400 ring-offset-2 animate-pulse z-20 shadow-xl bg-yellow-50 scale-105"; cursorClass = "cursor-pointer hover:bg-yellow-100"; }
            if (isTargetSelection) { cursorClass = "cursor-pointer"; }
            const resolvedIcon = special ? getIcon(special.icon) : null;

            return (
                <div 
                onClick={() => {
                    if (isPendingTarget) onCellClick();
                    else if (special && !isTargetSelection) onInfoClick({...special, icon: resolvedIcon});
                }}
                className={`relative w-full aspect-square border-2 rounded-xl flex flex-col p-1 shadow-sm transition-all duration-300 ${bgClass} ${borderClass} ${highlightClass} ${cursorClass}`}
                >
                <div className="flex justify-between items-start opacity-60">
                    <span className={`font-bold text-xs md:text-sm ${hasGem || isLava || isBlackHole ? 'text-white' : ''}`}>{num === 0 ? 'START' : num}</span>
                    {special && !isLava && !isBlackHole && <span className="text-xs">{resolvedIcon}</span>}
                    {isLava && <Flame className="text-yellow-300 fill-orange-600 animate-bounce" size={16}/>}
                    {isBlackHole && <Disc className="text-purple-500 animate-spin" size={12}/>}
                </div>
                {hasGem && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <Gem className="text-yellow-400 gem-glow animate-bounce" size={24} fill="gold"/>
                    </div>
                )}
                <div className="flex-1 flex flex-wrap content-center justify-center gap-1 z-10">
                    {infected && infected.position === num && (
                        <div className="relative z-30 animate-pulse">
                             <div className="rounded-full border-2 border-green-900 bg-green-500 p-1 shadow-lg">
                                <Biohazard size={20} className="text-green-900"/>
                             </div>
                        </div>
                    )}
                    {players.map(p => {
                        const teamColor = p.teamId !== undefined && TEAM_COLORS[p.teamId] ? TEAM_COLORS[p.teamId].border : 'border-white';
                        return (
                            <div key={p.id} onClick={(e) => {
                                if (isTargetSelection) {
                                    e.stopPropagation();
                                    // NO OP HERE, handled by list modal
                                }
                            }} className={`relative transition-all duration-300 ${p.finished || p.isDead ? 'opacity-50 scale-75' : 'hover:scale-125 hover:z-20'} ${isTargetSelection ? 'cursor-pointer' : ''}`}>
                                <div className={`rounded-full border-2 ${teamColor} p-[1px]`}>
                                    <PlayerAvatar charId={p.characterId} size="sm" border={false} />
                                </div>
                                {p.activeCurse && <div className="absolute -top-2 -right-2 bg-purple-900 text-white rounded-full p-0.5 border border-white z-20"><Ban size={10}/></div>}
                                {p.uid === bossTargetUid && <div className="absolute -top-3 -right-3 text-red-600 animate-pulse z-30 drop-shadow-md"><Crosshair size={24}/></div>}
                                {p.skipTurns > 0 && <div className="absolute inset-0 bg-black/50 rounded-full flex items-center justify-center text-white text-[10px] font-bold">{p.skipTurns}</div>}
                                {p.finished && <div className="absolute -top-1 -right-1 bg-green-500 text-white rounded-full p-0.5"><Flag size={8}/></div>}
                                {p.isDead && <div className="absolute inset-0 bg-black/70 rounded-full flex items-center justify-center"><Skull className="text-white" size={14}/></div>}
                            </div>
                        );
                    })}
                </div>
                {isPendingTarget && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <Pointer className="text-yellow-600 animate-bounce w-8 h-8 drop-shadow-md fill-yellow-300" />
                    </div>
                )}
                {special && <div className={`text-[8px] md:text-[10px] text-center leading-tight truncate font-semibold opacity-80 ${hasGem || isLava || isBlackHole ? 'text-white' : ''}`}>{special.name}</div>}
                </div>
            );
        };

        function App() {
            const [user, setUser] = useState(null);
            const [view, setView] = useState('menu');
            const [roomCode, setRoomCode] = useState('');
            const [nickname, setNickname] = useState('');
            const [currentRoom, setCurrentRoom] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [isMoving, setIsMoving] = useState(false); 
            const [lastRoll, setLastRoll] = useState(null);
            const [notif, setNotif] = useState(null); 
            const [selectedCellInfo, setSelectedCellInfo] = useState(null);
            const [useSpecialDie, setUseSpecialDie] = useState(false);
            const [directionChoice, setDirectionChoice] = useState(null); 
            const [decisionMode, setDecisionMode] = useState(false);
            const [decisionOptions, setDecisionOptions] = useState([]);
            const [targetSelectionMode, setTargetSelectionMode] = useState(null);
            const [bossTargetSelection, setBossTargetSelection] = useState(false);
            const [errorMsg, setErrorMsg] = useState(null);
            const [relayConfig, setRelayConfig] = useState({ teams: 2, size: 2 });

            const handleError = (error) => {
                console.error("Errore rilevato:", error);
                setErrorMsg(error.message || "Si è verificato un errore.");
                setTimeout(() => setErrorMsg(null), 8000); 
            };

            const generateEliminationSpecials = () => {
                const max = 34;
                const pool = [
                    { type: 'BOOST', val: 3, name: '+3', icon: 'Zap', desc: "Sprint! +3 caselle." },
                    { type: 'BOOST', val: 3, name: '+3', icon: 'Zap', desc: "Sprint! +3 caselle." },
                    { type: 'BOOST', val: 4, name: '+4', icon: 'Zap', desc: "Mega Sprint! +4 caselle." },
                    { type: 'DOUBLE', name: 'Raddoppia', icon: 'ChevronsUp', desc: "X2 Movimento!" },
                    { type: 'TAIL', name: 'In Coda', icon: 'Footprints', desc: "Ti metti in scia all'avversario!" },
                    { type: 'TAIL', name: 'In Coda', icon: 'Footprints', desc: "Ti metti in scia all'avversario!" }, 
                    { type: 'TELEPORT', name: 'Teletrasporto', icon: 'Shuffle', desc: "Scambio posizioni!" },
                    { type: 'SWITCH', name: 'Switch', icon: 'ArrowLeftRight', desc: "Scambi la posizione con un giocatore a caso." },
                    { type: 'DECISION', name: 'Decisione', icon: 'Gavel', desc: "Scegli il tuo destino!" },
                    { type: 'DECISION', name: 'Decisione', icon: 'Gavel', desc: "Scegli il tuo destino!" },
                    { type: 'BOOST', val: -2, name: '-2', icon: 'ArrowDown', desc: "Scivolata! Indietro di 2." },
                    { type: 'BACK_REL', val: 5, name: 'Trappola', icon: 'Bomb', desc: "Trappola! Indietro di 5." }, 
                    { type: 'BACK_REL', val: 10, name: 'Labirinto', icon: 'ArrowDown', desc: "Labirinto! Indietro di 10." }
                ];
                const specials = {};
                const usedPos = new Set([0, max]);
                pool.forEach(item => {
                    let pos;
                    let attempts = 0;
                    do { pos = Math.floor(Math.random() * (max - 2)) + 1; attempts++; } while (usedPos.has(pos) && attempts < 100);
                    if (!usedPos.has(pos)) {
                        usedPos.add(pos);
                        let finalItem = { ...item };
                        if (item.type === 'BACK_REL') { finalItem.type = 'BACK'; finalItem.val = Math.max(0, pos - item.val); }
                        specials[pos] = finalItem;
                    }
                });
                return specials;
            };

            useEffect(() => {
                const initAuth = async () => { try { await signInAnonymously(auth); } catch (e) { handleError(e); } };
                initAuth();
                return onAuthStateChanged(auth, u => setUser(u));
            }, []);

            useEffect(() => {
                if (!roomCode || !user) return;
                const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), (snap) => {
                    if (snap.exists()) {
                        const data = snap.data();
                        setCurrentRoom(data);
                        if (data.status === 'playing' && view !== 'game') setView('game');
                        if (data.status === 'waiting' && view !== 'lobby') setView('lobby');
                        
                        // Check if Boss needs to select target
                        if (data.status === 'playing' && data.gameMode === 'raid_boss' && data.players[data.currentTurn].uid === user.uid && data.bossTargetUid === null && data.players[data.currentTurn].uid === data.hostId) {
                            setBossTargetSelection(true);
                        } else {
                            setBossTargetSelection(false);
                        }
                    } else { setView('menu'); }
                }, (err) => { handleError(err); });
                return () => unsub();
            }, [roomCode, view, user]);

            useEffect(() => {
                if (currentRoom?.lastAction) {
                setNotif(currentRoom.lastAction);
                const t = setTimeout(() => setNotif(null), 3000);
                return () => clearTimeout(t);
                }
            }, [currentRoom?.lastAction]);

            const createRoom = async (mode) => {
                if (!nickname || !user) return;
                try {
                    const code = Math.random().toString(36).substring(2, 7).toUpperCase();
                    const charId = Math.floor(Math.random() * ROSTER.length);
                    let extraData = {};
                    if (mode === 'infection') extraData.infectedNPC = { position: 0, lastMovedRound: 0 };
                    if (mode === 'gem_hunt') {
                        const gems = [];
                        while(gems.length < 3) { const r = Math.floor(Math.random() * 40) + 5; if(!gems.includes(r)) gems.push(r); }
                        extraData.gemLocations = gems;
                    }
                    if (mode === 'lava') extraData.lavaTiles = [];
                    if (mode === 'elimination') extraData.customSpecials = generateEliminationSpecials();
                    if (mode === 'black_hole') extraData.blackHolePos = 0;
                    if (mode === 'raid_boss') {
                        extraData.bossHp = 50;
                        extraData.bossTargetUid = null;
                    }
                    if (mode === 'relay') {
                        extraData.teamBotModes = { 0: 'auto', 1: 'auto', 2: 'auto', 3: 'auto' };
                    }

                    const playerObj = { 
                        uid: user.uid, name: nickname, characterId: charId, position: 0, 
                        skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: false, 
                        pendingTarget: null, activeCurse: false, pawnIdx: 0 
                    };

                    if (mode === 'gem_hunt') playerObj.position = Math.random() > 0.5 ? 0 : 50;
                    if (mode === 'relay') playerObj.teamId = 0;
                    if (mode === 'gem_hunt') playerObj.collectedGems = [];
                    if (mode === 'lava') playerObj.lives = 2;
                    if (mode === 'raid_boss') playerObj.lives = 999; // Boss has HP, effectively infinite lives

                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', code), {
                        code, hostId: user.uid, gameMode: mode, teamConfig: mode === 'relay' ? relayConfig : null, status: 'waiting', currentTurn: 0, round: 1, ...extraData,
                        players: [playerObj],
                        lastAction: "Stanza Creata"
                    });
                    setRoomCode(code);
                    setView('lobby');
                } catch (e) { handleError(e); }
            };

            const joinRoom = async (codeOverride) => {
                const codeToJoin = codeOverride || roomCode;
                if (!nickname || !user || !codeToJoin) return;
                try {
                    const cleanCode = codeToJoin.toUpperCase().trim();
                    const ref = doc(db, 'artifacts', appId, 'public', 'data', 'matches', cleanCode);
                    const snap = await getDoc(ref);
                    if (!snap.exists()) { setErrorMsg(`Stanza ${cleanCode} non trovata!`); return; }
                    const data = snap.data();
                    if (data.status !== 'waiting') { setErrorMsg("La partita è già iniziata!"); return; }
                    setRoomCode(cleanCode);
                    if (data.players.some(p => p.uid === user.uid)) { setView('lobby'); return; }
                    const available = ROSTER.map(c=>c.id).filter(id => !data.players.some(p=>p.characterId === id));
                    const charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                    let bestTeam = 0;
                    if (data.gameMode === 'relay') {
                        const counts = Array(data.teamConfig.teams).fill(0);
                        data.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }
                    const startPos = data.gameMode === 'gem_hunt' ? (Math.random() > 0.5 ? 0 : 50) : 0;
                    const playerObj = { uid: user.uid, name: nickname, characterId: charId, position: startPos, skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: false, pendingTarget: null, activeCurse: false, pawnIdx: 0 };
                    if (data.gameMode === 'relay') playerObj.teamId = bestTeam;
                    if (data.gameMode === 'gem_hunt') playerObj.collectedGems = [];
                    if (data.gameMode === 'lava') playerObj.lives = 2;
                    if (data.gameMode === 'raid_boss') playerObj.lives = 3; // Raiders get 3 lives

                    await updateDoc(ref, { players: arrayUnion(playerObj) });
                    setView('lobby');
                } catch (e) { handleError(e); }
            };

            const startGame = async () => {
                try {
                    let gamePlayers = [...currentRoom.players];
                    if (currentRoom.gameMode === 'relay') {
                         const expandedPlayers = [];
                        const teamSize = currentRoom.teamConfig.size;
                        const numTeams = currentRoom.teamConfig.teams;
                        const teamUsers = Array.from({ length: numTeams }, () => []);
                        gamePlayers.forEach(p => { if (p.teamId < numTeams) teamUsers[p.teamId].push(p); });
                        for (let t = 0; t < numTeams; t++) {
                            const users = teamUsers[t];
                            if (users.length === 0) continue; 
                            for (let slot = 0; slot < teamSize; slot++) {
                                const userIndex = slot % users.length;
                                const baseUser = users[userIndex];
                                let charId = baseUser.characterId;
                                if (slot >= users.length) {
                                    const usedChars = new Set([...gamePlayers.map(p => p.characterId), ...expandedPlayers.map(p => p.characterId)]);
                                    const available = ROSTER.map(c => c.id).filter(id => !usedChars.has(id));
                                    charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                                }
                                expandedPlayers.push({ ...baseUser, id: `${baseUser.uid}_slot${slot}`, pawnIdx: slot, characterId: charId, position: 0, finished: false, skipTurns: 0, pendingTarget: null, activeCurse: false });
                            }
                        }
                        gamePlayers = [];
                        for(let slot=0; slot<teamSize; slot++) { for(let t=0; t<numTeams; t++) { const pawn = expandedPlayers.find(p => p.teamId === t && p.pawnIdx === slot); if(pawn) gamePlayers.push(pawn); } }
                    } else { gamePlayers = gamePlayers.map(p => ({...p, id: p.uid})); }
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { status: 'playing', lastAction: "Partita iniziata!", players: gamePlayers, currentTurn: 0 });
                } catch (e) { handleError(e); }
            };

            const addBot = async () => {
                if (!currentRoom || !user) return;
                try {
                    const availableChars = ROSTER.map(c => c.id).filter(id => !currentRoom.players.some(p => p.characterId === id));
                    const charId = availableChars.length > 0 ? availableChars[Math.floor(Math.random() * availableChars.length)] : 0;
                    const botId = `bot_${Date.now()}`;
                    const startPos = currentRoom.gameMode === 'gem_hunt' ? (Math.random() > 0.5 ? 0 : 50) : 0;
                    
                    let bestTeam = 0;
                    if (currentRoom.gameMode === 'relay') {
                        const counts = Array(currentRoom.teamConfig.teams).fill(0);
                        currentRoom.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }

                    const botPlayer = {
                        uid: botId,
                        name: `Bot ${Math.floor(Math.random() * 1000)}`,
                        characterId: charId,
                        position: startPos,
                        skipTurns: 0,
                        finished: false,
                        isDead: false,
                        rank: 0,
                        isBot: true,
                        pendingTarget: null,
                        activeCurse: false,
                        pawnIdx: 0,
                        ...(currentRoom.gameMode === 'relay' ? { teamId: bestTeam } : {}),
                        ...(currentRoom.gameMode === 'gem_hunt' ? { collectedGems: [] } : {}),
                        ...(currentRoom.gameMode === 'lava' ? { lives: 2 } : {}),
                        ...(currentRoom.gameMode === 'raid_boss' ? { lives: 3 } : {})
                    };

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        players: arrayUnion(botPlayer)
                    });
                } catch (e) {
                    handleError(e);
                }
            };

            const selectChar = async (charId) => {
                if (!currentRoom || !user) return;
                try {
                    const playerIndex = currentRoom.players.findIndex(p => p.uid === user.uid);
                    if (playerIndex === -1) return;
                    
                    const updatedPlayers = [...currentRoom.players];
                    // Check if char is taken by someone else
                    if (updatedPlayers.some(p => p.characterId === charId && p.uid !== user.uid)) return;

                    updatedPlayers[playerIndex] = { ...updatedPlayers[playerIndex], characterId: charId };
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        players: updatedPlayers
                    });
                } catch (e) {
                    handleError(e);
                }
            };

            const switchTeam = async (newTeamId) => {
                if (!currentRoom || !user) return;
                const playerIdx = currentRoom.players.findIndex(p => p.uid === user.uid);
                if (playerIdx === -1) return;
                let updated = [...currentRoom.players];
                updated[playerIdx] = { ...updated[playerIdx], teamId: newTeamId };
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
            };

            const toggleBotModeLobby = async (teamId) => {
                 if (!currentRoom) return;
                const currentMode = currentRoom.teamBotModes?.[teamId] || 'auto';
                const newMode = currentMode === 'auto' ? 'manual' : 'auto';
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                    [`teamBotModes.${teamId}`]: newMode
                });
            }

            const isPawnLocked = (pawn, allPlayers) => {
                if (currentRoom.gameMode !== 'relay') return false;
                if (pawn.pawnIdx === 0) return false; 
                const teammate = allPlayers.find(p => p.teamId === pawn.teamId && p.pawnIdx === pawn.pawnIdx - 1);
                return teammate && !teammate.finished;
            };

            const checkTeamWin = (players, teamId) => {
                const teamPawns = players.filter(p => p.teamId === teamId);
                return teamPawns.every(p => p.finished);
            };

            const executeMove = async (playerId, targetPos) => {
                if (isMoving) return;
                setIsMoving(true);
                playSound('click');
                setDirectionChoice(null);
                try {
                    const currentPlayerIdx = currentRoom.currentTurn;
                    const player = currentRoom.players[currentPlayerIdx];
                    const currentPos = player.position;
                    const config = currentRoom.gameMode === 'elimination' ? ELIM_MAP : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP : CLASSIC_MAP);
                    let effectiveSpecials = config.specials;
                    if (currentRoom.gameMode === 'elimination' && currentRoom.customSpecials) effectiveSpecials = currentRoom.customSpecials;
                    
                    const isBoss = currentRoom.gameMode === 'raid_boss' && player.uid === currentRoom.hostId;
                    
                    const steps = [];
                    const direction = targetPos >= currentPos ? 1 : -1;
                    const dist = Math.abs(targetPos - currentPos); 
                    for (let i = 1; i <= dist; i++) steps.push(currentPos + (i * direction));
                    let tempPlayers = [...currentRoom.players];
                    let gemsCollectedThisTurn = [...(player.collectedGems || [])];
                    let tempGemLocations = [...(currentRoom.gemLocations || [])];
                    let tempBossHp = currentRoom.bossHp;
                    let collisionLog = [];

                    for (let stepPos of steps) {
                        tempPlayers[currentPlayerIdx] = { ...tempPlayers[currentPlayerIdx], position: stepPos };
                        
                        // RAID BOSS COLLISION LOGIC ON STEP
                        if (currentRoom.gameMode === 'raid_boss') {
                            const boss = tempPlayers.find(p => p.uid === currentRoom.hostId);
                            const raiders = tempPlayers.filter(p => p.uid !== currentRoom.hostId && !p.isDead && p.position === stepPos);
                            
                            if (isBoss) {
                                // Boss moves over raiders
                                raiders.forEach(r => {
                                    if (r.uid === currentRoom.bossTargetUid) {
                                        // Specific rule: If interaction with target, target loses life
                                        const rIdx = tempPlayers.findIndex(p => p.uid === r.uid);
                                        tempPlayers[rIdx].lives -= 1;
                                        collisionLog.push(`${r.name} colpito dal BOSS!`);
                                        playSound('punch');
                                        if (tempPlayers[rIdx].lives <= 0) tempPlayers[rIdx].isDead = true;
                                    } else {
                                        // Normal raider hit by boss moving -> Raider damage
                                        const rIdx = tempPlayers.findIndex(p => p.uid === r.uid);
                                        tempPlayers[rIdx].lives -= 1;
                                        collisionLog.push(`${r.name} calpestato dal BOSS!`);
                                        playSound('punch');
                                        if (tempPlayers[rIdx].lives <= 0) tempPlayers[rIdx].isDead = true;
                                    }
                                });
                            } else {
                                // Raider moves over boss
                                if (boss && boss.position === stepPos) {
                                    if (player.uid === currentRoom.bossTargetUid) {
                                        // Target hits boss -> TARGET loses life instead of boss taking damage
                                        tempPlayers[currentPlayerIdx].lives -= 1;
                                        collisionLog.push(`${player.name} (Bersaglio) si schianta sul BOSS!`);
                                        playSound('punch');
                                        if (tempPlayers[currentPlayerIdx].lives <= 0) tempPlayers[currentPlayerIdx].isDead = true;
                                    } else {
                                        // Normal raider hits boss -> Boss Damage
                                        const dmg = lastRoll || 1;
                                        tempBossHp -= dmg;
                                        collisionLog.push(`BOSS colpito! -${dmg} HP`);
                                        playSound('boss_hit');
                                    }
                                }
                            }
                        }

                        if (currentRoom.gameMode === 'gem_hunt' && tempGemLocations.includes(stepPos)) {
                             if (!gemsCollectedThisTurn.includes(stepPos)) {
                                 gemsCollectedThisTurn.push(stepPos);
                                 tempPlayers[currentPlayerIdx].collectedGems = gemsCollectedThisTurn;
                                 tempGemLocations = tempGemLocations.filter(g => g !== stepPos);
                                 let newGem = -1;
                                 while(newGem === -1 || tempGemLocations.includes(newGem) || newGem === stepPos || newGem === 0 || newGem === 50) newGem = Math.floor(Math.random() * 41) + 5; 
                                 tempGemLocations.push(newGem);
                                 playSound('gem');
                             }
                        }
                        let intermediateUpdate = { players: tempPlayers };
                        if (currentRoom.gameMode === 'gem_hunt') intermediateUpdate.gemLocations = tempGemLocations;
                        if (currentRoom.gameMode === 'raid_boss') intermediateUpdate.bossHp = tempBossHp;
                        await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), intermediateUpdate);
                        if (!tempGemLocations.includes(stepPos)) playSound('step');
                        await sleep(250); 
                    }

                    let finalPos = targetPos;
                    let log = `${player.name} è alla ${finalPos}.`;
                    if (collisionLog.length > 0) log += " " + collisionLog.join(" ");

                    // *** LAVA CHECK ON ARRIVAL (PRE-SPECIAL) ***
                    if (currentRoom.gameMode === 'lava' && currentRoom.lavaTiles && currentRoom.lavaTiles.includes(finalPos)) {
                        tempPlayers[currentPlayerIdx].lives -= 1;
                        log += " 🔥 LAVA! -1 VITA!";
                        playSound('fire');
                        if (tempPlayers[currentPlayerIdx].lives <= 0) {
                            tempPlayers[currentPlayerIdx].isDead = true;
                            tempPlayers[currentPlayerIdx].finished = true; // Mark finished to skip turn
                            log += " ELIMINATO!";
                            playSound('skull');
                        }
                    }

                    let special = effectiveSpecials[finalPos];
                    let extraTurns = 0;
                    if (special && !tempPlayers[currentPlayerIdx].isDead) {
                        log += ` ${special.name}!`; 
                        if (special.type === 'BOOST') { await sleep(500); finalPos += special.val; if (finalPos < 0) finalPos = 0; if (finalPos > config.max) finalPos = config.max; tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'JUMP' || special.type === 'BACK' || special.type === 'RESTART') { await sleep(800); finalPos = special.val || 0; tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'DOUBLE') { await sleep(800); const moveAmt = dist; finalPos = finalPos + (moveAmt * direction); if (finalPos > config.max) finalPos = config.max; if (finalPos < 0) finalPos = 0; tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'TAIL') { await sleep(800); const sortedByPos = [...tempPlayers].filter(p => !p.isDead).sort((a,b) => b.position - a.position); const myRankIdx = sortedByPos.findIndex(p => p.id === player.id); if (myRankIdx > 0) { const targetPlayer = sortedByPos[myRankIdx - 1]; finalPos = Math.max(0, targetPlayer.position - 1); } tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'TELEPORT') {
                            await sleep(800);
                            const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (currentRoom.gameMode !== 'relay' || p.teamId !== player.teamId));
                            if (others.length > 0) { const targetP = others[Math.floor(Math.random() * others.length)]; finalPos = targetP.position; tempPlayers[currentPlayerIdx].position = finalPos; playSound('teleport'); }
                        }
                        else if (special.type === 'SWITCH') {
                            await sleep(800);
                             const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (currentRoom.gameMode !== 'relay' || p.teamId !== player.teamId));
                            if (others.length > 0) {
                                const targetP = others[Math.floor(Math.random() * others.length)];
                                const targetIndex = tempPlayers.findIndex(p => p.id === targetP.id);
                                const myPos = finalPos; 
                                const theirPos = targetP.position;
                                tempPlayers[currentPlayerIdx].position = theirPos;
                                tempPlayers[targetIndex].position = myPos;
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers });
                                playSound('teleport');
                                finalPos = theirPos; 
                            }
                        }
                        else if (special.type === 'DECISION') {
                            if (player.isBot) {
                                // BOT DECISION LOGIC
                                const picked = DECISION_POOL[Math.floor(Math.random() * DECISION_POOL.length)];
                                log += ` Scelta Bot: ${picked.name}!`;
                                if (picked.id === 'target_back_4' || picked.id === 'curse') {
                                     const validTargets = tempPlayers.filter(p => p.id !== player.id && !p.finished && !p.isDead);
                                     if (validTargets.length > 0) {
                                         const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                                         const tIdx = tempPlayers.findIndex(p => p.id === target.id);
                                         if (picked.id === 'target_back_4') {
                                             tempPlayers[tIdx].position = Math.max(0, tempPlayers[tIdx].position - 4);
                                             log += ` Colpisce ${target.name}!`;
                                         } else {
                                             tempPlayers[tIdx].activeCurse = true;
                                             log += ` Maledice ${target.name}!`;
                                         }
                                     }
                                } else if (picked.id === 'all_1_me_3') {
                                    tempPlayers = tempPlayers.map(p => { if (p.isDead || p.finished) return p; let move = (p.id === player.id) ? 3 : 1; return { ...p, position: Math.min(p.position + move, 60) }; });
                                } else if (picked.id === 'teleport') {
                                     const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished);
                                     if(others.length > 0) tempPlayers[currentPlayerIdx].position = others[Math.floor(Math.random()*others.length)].position;
                                } else if (picked.id === 'turbo') {
                                    finalPos = Math.min(finalPos + 4, 60);
                                    tempPlayers[currentPlayerIdx].position = finalPos;
                                }
                            } else {
                                await sleep(500);
                                const shuffled = [...DECISION_POOL].sort(() => 0.5 - Math.random());
                                setDecisionOptions(shuffled.slice(0, 3));
                                setDecisionMode(true);
                                setTargetSelectionMode(null);
                                tempPlayers[currentPlayerIdx].position = finalPos;
                                tempPlayers[currentPlayerIdx].pendingTarget = null; // FIX: Clear pendingTarget immediately to prevent loop
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers, bossHp: tempBossHp, lastAction: `${player.name} sta scegliendo...` });
                                setIsMoving(false); return; 
                            }
                        }
                        if (special.type === 'WAIT') extraTurns = special.turns;
                    }

                    // *** LAVA CHECK ON DESTINATION (POST-SPECIAL) ***
                    // We only apply damage if we MOVED to a new tile (finalPos !== targetPos)
                    // This prevents double damage on the same tile.
                    if (finalPos !== targetPos && !tempPlayers[currentPlayerIdx].isDead && currentRoom.gameMode === 'lava' && currentRoom.lavaTiles && currentRoom.lavaTiles.includes(finalPos)) {
                        tempPlayers[currentPlayerIdx].lives -= 1;
                        log += " 🔥 ATTERRATO SU LAVA! -1 VITA!";
                        playSound('fire');
                        if (tempPlayers[currentPlayerIdx].lives <= 0) {
                            tempPlayers[currentPlayerIdx].isDead = true;
                            tempPlayers[currentPlayerIdx].finished = true; 
                            log += " ELIMINATO!";
                            playSound('skull');
                        }
                    }

                    // CHECK BLACK HOLE
                    if (currentRoom.gameMode === 'black_hole' && finalPos <= currentRoom.blackHolePos) {
                        tempPlayers[currentPlayerIdx].isDead = true;
                        tempPlayers[currentPlayerIdx].finished = true;
                        log += " RISUCCHIATO DAL BUCO NERO!";
                        playSound('suck');
                    }

                    if (currentRoom.gameMode === 'classic_punitive') {
                         const victims = tempPlayers.filter(p => p.id !== player.id && p.position === finalPos && !p.finished && !p.isDead);
                         if (victims.length > 0) { victims.forEach(v => { const vIndex = tempPlayers.findIndex(tp => tp.id === v.id); tempPlayers[vIndex].position = Math.max(0, v.position - 3); }); playSound('punch'); }
                    }
                    tempPlayers[currentPlayerIdx] = { ...tempPlayers[currentPlayerIdx], position: finalPos, skipTurns: extraTurns, pendingTarget: null };
                    let updates = { players: tempPlayers, lastAction: log };
                    if (currentRoom.gameMode === 'gem_hunt') updates.gemLocations = tempGemLocations;
                    if (currentRoom.gameMode === 'raid_boss') updates.bossHp = tempBossHp;

                    // WIN CONDITION CHECK
                    let justFinished = false;
                    if (currentRoom.gameMode === 'gem_hunt' && tempPlayers[currentPlayerIdx].collectedGems.length >= 5) { // GEM LIMIT 5
                        tempPlayers[currentPlayerIdx].finished = true; 
                        playSound('win');
                        justFinished = true;
                    }
                    else if (finalPos === config.max && !tempPlayers[currentPlayerIdx].isDead) { 
                        if (currentRoom.gameMode === 'raid_boss' && isBoss) {
                             // Boss Reaches End -> Boss Wins (Game Over for Raiders)
                             updates.status = 'finished';
                             updates.winner = "IL BOSS HA VINTO!";
                             playSound('skull');
                        } else {
                            tempPlayers[currentPlayerIdx].finished = true; 
                            playSound('win'); 
                            justFinished = true;
                        }
                    }
                    
                    if (currentRoom.gameMode === 'raid_boss' && tempBossHp <= 0) {
                         updates.status = 'finished';
                         updates.winner = "GIOCATORI VINCONO! BOSS SCONFITTO!";
                         playSound('win');
                    }
                    
                    const totalPlayers = tempPlayers.length;
                    const finishedPlayers = tempPlayers.filter(p => p.finished);
                    const activePlayers = tempPlayers.filter(p => !p.isDead); // For elimination, counts living
                    const finishedCount = finishedPlayers.length;

                    if (justFinished) {
                         // Assign rank based on finish order
                         tempPlayers[currentPlayerIdx].rank = finishedCount; 
                         log += " ARRIVATO!";
                    }

                    if (currentRoom.gameMode === 'relay') {
                         const teams = currentRoom.teamConfig.teams;
                         const finishedTeams = [];
                         for(let t=0; t<teams; t++) {
                             if (checkTeamWin(tempPlayers, t)) finishedTeams.push(t);
                         }
                         if (finishedTeams.length >= teams - 1 && teams > 1) {
                              updates.status = 'finished';
                              updates.winner = "GARA COMPLETATA";
                         } else {
                              const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                              updates.currentTurn = nextTurn;
                         }
                    } else if (currentRoom.gameMode === 'elimination') {
                        // Elimination ends when 1 survivor remains
                        const living = tempPlayers.filter(p => !p.isDead);
                        const finishedLiving = living.filter(p => p.finished);
                        if (finishedLiving.length === living.length - 1 && living.length > 1) {
                            const loser = living.find(p => !p.finished);
                            const loserIndex = tempPlayers.findIndex(p => p.id === loser.id);
                            tempPlayers[loserIndex].isDead = true;
                            // Reset for next round
                            tempPlayers.forEach(p => { if (!p.isDead) { p.position = 0; p.finished = false; } });
                            updates.players = tempPlayers; 
                            updates.round = currentRoom.round + 1; 
                            updates.customSpecials = generateEliminationSpecials(); 
                            updates.currentTurn = 0;
                        } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            updates.currentTurn = nextTurn;
                        }
                    } else if (currentRoom.gameMode === 'raid_boss') {
                        const livingRaiders = tempPlayers.filter(p => p.uid !== currentRoom.hostId && !p.isDead);
                        if (livingRaiders.length === 0) {
                            updates.status = 'finished';
                            updates.winner = "BOSS HA VINTO (TUTTI MORTI)!";
                        } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn === 0) {
                                updates.round = (currentRoom.round || 1) + 1;
                                updates.bossTargetUid = null; // Reset boss target for new round
                            }
                            updates.currentTurn = nextTurn;
                        }
                    } else if (currentRoom.gameMode === 'lava' || currentRoom.gameMode === 'black_hole') {
                        const living = tempPlayers.filter(p => !p.isDead);
                        const arrived = living.filter(p => p.finished);

                        if (arrived.length >= living.length - 1 && living.length > 1) {
                            updates.status = 'finished'; 
                            updates.winner = "GARA TERMINATA!";
                        } else if (living.length === 0) {
                            updates.status = 'finished'; 
                            updates.winner = "NESSUN SOPRAVVISSUTO!";
                        } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn === 0) {
                                // NEW ROUND
                                updates.round = (currentRoom.round || 1) + 1;
                                
                                if (currentRoom.gameMode === 'lava') {
                                    let newLava = -1;
                                    const existingLava = currentRoom.lavaTiles || [];
                                    let attempts = 0;
                                    while((newLava === -1 || newLava === 0 || newLava === 60 || existingLava.includes(newLava)) && attempts < 100) {
                                        newLava = Math.floor(Math.random() * 59) + 1;
                                        attempts++;
                                    }
                                    if (newLava !== -1) {
                                        updates.lavaTiles = [...existingLava, newLava];
                                        updates.lastAction = `ROUND ${updates.round}: LAVA A ${newLava}!`;
                                        playSound('fire');
                                    }
                                }
                                
                                if (currentRoom.gameMode === 'black_hole') {
                                    updates.blackHolePos = (currentRoom.blackHolePos || 0) + 3;
                                    updates.lastAction = `ROUND ${updates.round}: IL BUCO NERO AVANZA A ${updates.blackHolePos}!`;
                                    playSound('suck');
                                    // Kill players
                                    tempPlayers = tempPlayers.map(p => {
                                        if (p.position <= updates.blackHolePos && !p.finished && !p.isDead) {
                                            return { ...p, isDead: true, finished: true };
                                        }
                                        return p;
                                    });
                                    updates.players = tempPlayers;
                                }

                                updates.currentTurn = 0;
                            } else {
                                updates.currentTurn = nextTurn;
                            }
                        }
                    } else {
                        // Classic, Infection, Gem Hunt: Wait until N-1 players finish
                        if (finishedCount >= totalPlayers - 1 && totalPlayers > 1) { 
                            updates.status = 'finished'; 
                            updates.winner = "TUTTI ARRIVATI!"; 
                        } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn === 0 && currentRoom.gameMode === 'infection') {
                                updates.round = (currentRoom.round || 1) + 1;
                                // INFECTION MOVE LOGIC ATOMIC
                                if (updates.round > 3) {
                                    const infectionSteps = [2, 3, 5, 7, 8];
                                    const roll = infectionSteps[Math.floor(Math.random() * infectionSteps.length)];
                                    const oldNpcPos = currentRoom.infectedNPC.position;
                                    const newNpcPos = oldNpcPos + roll;
                                    updates['infectedNPC.position'] = newNpcPos;
                                    updates['infectedNPC.lastMovedRound'] = updates.round;
                                    
                                    let killCount = 0;
                                    // Need to recalculate players with deaths
                                    tempPlayers = tempPlayers.map(p => {
                                        if (!p.isDead && !p.finished && p.position <= newNpcPos) {
                                            killCount++;
                                            return { ...p, isDead: true, position: 0 };
                                        }
                                        return p;
                                    });
                                    updates.players = tempPlayers; // Overwrite players with death updates
                                    updates.lastAction = `ROUND ${updates.round}: Virus avanza di ${roll}! ${killCount > 0 ? killCount + ' presi!' : ''}`;
                                    playSound('zombie');
                                } else {
                                    updates.lastAction = `ROUND ${updates.round}: Il virus dorme...`;
                                }
                                updates.currentTurn = 0;
                            } else {
                                updates.currentTurn = nextTurn;
                            }
                        }
                    }

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                } catch (e) { handleError(e); }
                setIsMoving(false);
            };

            const confirmGemMove = async (dir) => {
                 if (!directionChoice) return;
                 const playerIdx = currentRoom.currentTurn;
                 const player = currentRoom.players[playerIdx];
                 let newPos = player.position + (directionChoice.val * dir);
                 if (newPos > 50) newPos = 50; if (newPos < 0) newPos = 0;
                 const updated = [...currentRoom.players];
                 updated[playerIdx] = { ...player, pendingTarget: newPos };
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
                 setDirectionChoice(null);
            };

            const handleDecisionEffect = async (option) => {
                if (!option || !currentRoom) return;
                const playerIdx = currentRoom.currentTurn;
                const player = currentRoom.players[playerIdx];
                if (option.id === 'target_back_4' || option.id === 'curse') { setTargetSelectionMode(option.id); return; }
                
                let updatedPlayers = [...currentRoom.players];
                // FIX: Clear pendingTarget to prevent loop on next turn
                updatedPlayers[playerIdx] = { ...updatedPlayers[playerIdx], pendingTarget: null };

                if (option.id === 'all_1_me_3') { updatedPlayers = updatedPlayers.map(p => { if (p.isDead || p.finished) return p; let move = (p.id === player.id) ? 3 : 1; return { ...p, position: Math.min(p.position + move, 60) }; }); }
                else if (option.id === 'teleport') { const others = updatedPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (currentRoom.gameMode !== 'relay' || p.teamId !== player.teamId)); if (others.length > 0) { const target = others[Math.floor(Math.random() * others.length)]; updatedPlayers[playerIdx].position = target.position; playSound('teleport'); } }
                else if (option.id === 'reroll') { 
                    // Reroll: Clear pending target, keep turn, save to DB
                    setDecisionMode(false); 
                    setDecisionOptions([]); 
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, lastAction: `${player.name} tira di nuovo!` });
                    return; 
                }
                else if (option.id === 'turbo') { updatedPlayers[playerIdx].position = Math.min(player.position + 4, 60); }
                
                setDecisionMode(false); setDecisionOptions([]);
                const nextTurn = getNextTurn(updatedPlayers, playerIdx);
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, currentTurn: nextTurn, lastAction: `${player.name} usa ${option.name}!` });
            };

            const handleTargetClick = async (targetUid) => {
                // Handle Boss Target Selection
                if (bossTargetSelection) {
                     await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { bossTargetUid: targetUid });
                     setBossTargetSelection(false);
                     return;
                }

                if (!targetSelectionMode || !currentRoom) return;
                const targetIdx = currentRoom.players.findIndex(p => p.uid === targetUid);
                const playerIdx = currentRoom.currentTurn;
                if (targetIdx === -1 || targetIdx === playerIdx) return;
                let updatedPlayers = [...currentRoom.players];
                
                // FIX: Clear pendingTarget for the current player
                updatedPlayers[playerIdx] = { ...updatedPlayers[playerIdx], pendingTarget: null };

                if (targetSelectionMode === 'target_back_4') { updatedPlayers[targetIdx].position = Math.max(0, updatedPlayers[targetIdx].position - 4); playSound('punch'); }
                else if (targetSelectionMode === 'curse') { updatedPlayers[targetIdx].activeCurse = true; playSound('curse'); }
                setTargetSelectionMode(null); setDecisionMode(false); setDecisionOptions([]);
                const nextTurn = getNextTurn(updatedPlayers, playerIdx);
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, currentTurn: nextTurn, lastAction: `${updatedPlayers[playerIdx].name} colpisce ${updatedPlayers[targetIdx].name}!` });
            };

            const handleRoll = async () => {
                if (isRolling || isMoving || !currentRoom) return;
                const playerIdx = currentRoom.currentTurn;
                const player = currentRoom.players[playerIdx];
                const me = currentRoom.players.find(p => p.uid === user.uid);
                
                // Staffetta: puoi controllare i bot del tuo team
                // NUOVA LOGICA: Controllo manuale SE il team è in modalità 'manual'
                const teamMode = currentRoom.teamBotModes?.[player.teamId] || 'auto';
                const isMyTeamBot = player.isBot && currentRoom.gameMode === 'relay' && me && player.teamId === me.teamId && teamMode === 'manual';
                const isHostControllingBot = player.isBot && currentRoom.hostId === user.uid && currentRoom.gameMode !== 'relay';

                if (player.uid !== user.uid && !isMyTeamBot && !isHostControllingBot) return;
                
                try {
                    if (isPawnLocked(player, currentRoom.players)) { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { currentTurn: getNextTurn(currentRoom.players, playerIdx) }); return; }
                    if (player.skipTurns > 0) { let updated = [...currentRoom.players]; updated[playerIdx].skipTurns -= 1; await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated, currentTurn: getNextTurn(updated, playerIdx) }); return; }
                    setIsRolling(true); playSound('step');
                    
                    const isBoss = currentRoom.gameMode === 'raid_boss' && player.uid === currentRoom.hostId;
                    
                    let vals = [];
                    if (isBoss) {
                        vals = BOSS_DICE_VALS;
                    } else {
                        const charId = (player.characterId >= 0 && player.characterId < ROSTER.length) ? player.characterId : 0;
                        const specialDice = ROSTER[charId].dice;
                        vals = player.activeCurse ? [2, 2, 1, 1, 0, -1] : (useSpecialDie ? specialDice.vals : [1,2,3,4,5,6]);
                    }

                    for(let i=0; i<10; i++) { setLastRoll(vals[Math.floor(Math.random() * vals.length)]); await sleep(50); }
                    let val = vals[Math.floor(Math.random() * vals.length)];
                    setLastRoll(val); await sleep(200);
                    let updated = [...currentRoom.players];
                    updated[playerIdx].activeCurse = false;
                    if (currentRoom.gameMode === 'gem_hunt') { val = Math.abs(val); setDirectionChoice({ val }); setIsRolling(false); return; }
                    
                    // FIX BUG 1: Use specific max value depending on game mode
                    const config = currentRoom.gameMode === 'elimination' ? ELIM_MAP : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP : CLASSIC_MAP);
                    let newPos = Math.max(0, Math.min(player.position + val, config.max));
                    
                    updated[playerIdx].pendingTarget = newPos;
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated, lastAction: `${player.name} fa ${val}!` });
                } catch (e) { handleError(e); }
                setIsRolling(false);
            };

            const toggleBotMode = async () => {
                if (!currentRoom || !me) return;
                const currentMode = currentRoom.teamBotModes?.[me.teamId] || 'auto';
                const newMode = currentMode === 'auto' ? 'manual' : 'auto';
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                    [`teamBotModes.${me.teamId}`]: newMode
                });
            };

            const getNextTurn = (players, currentIdx) => {
                let next = (currentIdx + 1) % players.length;
                let loop = 0;
                // Skip dead, already finished players (unless only 1 left?), or locked players
                while(loop < players.length * 2 && (players[next].isDead || players[next].finished || (players[next].skipTurns > 0 && players[next].skipTurns > 0) || isPawnLocked(players[next], players))) {
                    if (players[next].skipTurns > 0) break;
                    next = (next + 1) % players.length; loop++;
                }
                return next;
            };

            useEffect(() => {
                if (currentRoom?.status === 'playing') {
                    const p = currentRoom.players[currentRoom.currentTurn];
                    if (!p) return;
                    
                    // Staffetta Logic for Automation
                    // Run automation ONLY if team mode is 'auto'
                    const teamMode = currentRoom.teamBotModes?.[p.teamId] || 'auto';
                    const shouldAutoRun = p.isBot && currentRoom.hostId === user?.uid && !isRolling && !isMoving && !decisionMode && !directionChoice && teamMode === 'auto';
                    
                    // Standard bot logic (Host controls generic bots unless relay override)
                    const isGenericBot = p.isBot && currentRoom.gameMode !== 'relay' && currentRoom.hostId === user?.uid && !isRolling && !isMoving && !decisionMode && !directionChoice;

                    if (shouldAutoRun || isGenericBot) {
                        if (p.pendingTarget === null) { const t = setTimeout(() => handleRoll(), 1500); return () => clearTimeout(t); }
                        else { const t = setTimeout(() => executeMove(p.uid, p.pendingTarget), 1500); return () => clearTimeout(t); }
                    }
                }
            }, [currentRoom, isRolling, isMoving, user, directionChoice, decisionMode]);

            if (!user) return <div className="h-screen flex items-center justify-center bg-slate-900 text-white font-black">MULTIVERSE RUN</div>;
            const currentPlayer = currentRoom?.players?.[currentRoom.currentTurn];
            const me = currentRoom?.players?.find(p => p.uid === user.uid);
            
            // Determine if "Leader" of the team (simplification: first human in the team list)
            const myTeamPlayers = currentRoom?.players?.filter(p => !p.isBot && p.teamId === me?.teamId) || [];
            const isLeader = myTeamPlayers.length > 0 && myTeamPlayers[0].uid === user.uid;

            const teamMode = currentRoom?.teamBotModes?.[currentPlayer?.teamId] || 'auto';
            const canControlCurrent = currentPlayer && (
                currentPlayer.uid === user.uid || 
                (currentPlayer.isBot && currentRoom.gameMode === 'relay' && me && currentPlayer.teamId === me.teamId && teamMode === 'manual')
            );

            return (
                <div className="min-h-screen bg-slate-50 text-slate-800 font-sans flex flex-col relative">
                
                {/* MODAL TARGET SELECTION (GENERIC + BOSS) */}
                {(targetSelectionMode || bossTargetSelection) && canControlCurrent && (
                    <div className="fixed inset-0 z-[80] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-in fade-in">
                        <div className="max-w-md w-full bg-white rounded-2xl shadow-2xl border-4 border-indigo-500 overflow-hidden flex flex-col max-h-[80vh]">
                            <div className="p-4 bg-indigo-600 text-white text-center">
                                <h3 className="font-black text-xl uppercase flex items-center justify-center gap-2"><Target/> {bossTargetSelection ? "MARCHIA UN BERSAGLIO" : "Seleziona Bersaglio"}</h3>
                                <p className="text-xs opacity-75">{bossTargetSelection ? "Il Boss sceglie la sua preda!" : "Chi vuoi colpire?"}</p>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2">
                                {currentRoom.players
                                    .filter(p => p.uid !== currentPlayer.uid && !p.finished && !p.isDead && (!bossTargetSelection || p.uid !== currentRoom.hostId))
                                    .sort((a,b) => b.position - a.position)
                                    .map(p => (
                                    <button key={p.uid} onClick={() => handleTargetClick(p.uid)} className="w-full flex items-center gap-4 p-3 rounded-xl border-2 border-slate-100 hover:border-red-500 hover:bg-red-50 transition-all group">
                                        <div className="relative">
                                            <PlayerAvatar charId={p.characterId} size="md" border={false}/>
                                            <div className="absolute -top-2 -right-2 bg-slate-800 text-white text-xs font-bold px-1.5 py-0.5 rounded-full border border-white">{p.position}</div>
                                        </div>
                                        <div className="flex-1 text-left">
                                            <div className="font-black text-slate-800 text-lg leading-none group-hover:text-red-600">{p.name}</div>
                                            {p.teamId !== undefined && <div className={`text-[10px] uppercase font-bold text-slate-400`}>Team {p.teamId+1}</div>}
                                            {p.uid === currentRoom.bossTargetUid && <div className="text-xs font-bold text-red-500">ATTUALE BERSAGLIO</div>}
                                        </div>
                                        <Pointer className="text-slate-300 group-hover:text-red-500 -rotate-90"/>
                                    </button>
                                ))}
                                {currentRoom.players.filter(p => p.uid !== currentPlayer.uid && !p.finished && !p.isDead).length === 0 && (
                                    <div className="p-8 text-center text-slate-400 italic">Nessun bersaglio disponibile!</div>
                                )}
                            </div>
                            {!bossTargetSelection && <button onClick={() => {setTargetSelectionMode(null); setDecisionMode(false);}} className="p-4 bg-slate-200 font-bold hover:bg-slate-300 transition-colors">ANNULLA</button>}
                        </div>
                    </div>
                )}

                {/* MODAL DECISIONE (A pieno schermo solo quando scegli l'opzione) */}
                {decisionMode && !targetSelectionMode && canControlCurrent && (
                    <div className="fixed inset-0 z-[70] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-in fade-in">
                        <div className="max-w-md w-full flex flex-col items-center gap-4">
                            <div className="text-3xl font-black text-white drop-shadow-lg mb-4 flex items-center gap-2"><Gavel size={32} className="text-yellow-400"/> SCEGLI IL DESTINO</div>
                            <div className="grid grid-cols-1 gap-3 w-full">
                                {decisionOptions.map(opt => (
                                    <button key={opt.id} onClick={() => handleDecisionEffect(opt)} className="bg-white p-4 rounded-xl flex items-center gap-4 hover:scale-105 transition-all shadow-xl group">
                                        <div className="p-3 bg-indigo-100 rounded-full text-indigo-600 group-hover:bg-indigo-600 group-hover:text-white transition-colors">{opt.icon}</div>
                                        <div className="text-left">
                                            <div className="font-black text-lg text-slate-900">{opt.name}</div>
                                            <div className="text-xs text-slate-500 font-medium">{opt.desc}</div>
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                )}

                {/* INFO CASELLA */}
                {selectedCellInfo && (
                    <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm">
                        <div className="bg-white rounded-2xl p-6 max-w-sm w-full shadow-2xl relative border-4 border-indigo-200">
                            <button onClick={()=>setSelectedCellInfo(null)} className="absolute top-2 right-2 p-1 rounded-full hover:bg-slate-100"><X size={20}/></button>
                            <div className="flex flex-col items-center text-center gap-3">
                                <div className="p-4 bg-indigo-50 rounded-full text-indigo-600 scale-125">{selectedCellInfo.icon}</div>
                                <h3 className="text-2xl font-black text-indigo-900">{selectedCellInfo.name}</h3>
                                <p className="text-lg text-slate-600 font-medium">{selectedCellInfo.desc}</p>
                            </div>
                        </div>
                    </div>
                )}

                {errorMsg && <div className="fixed top-0 left-0 w-full bg-red-600 text-white text-center p-2 z-[150] font-black uppercase tracking-tighter"><AlertCircle className="inline mr-2" /> {errorMsg}</div>}

                <div className="bg-indigo-900 text-white p-3 flex justify-between items-center shadow-lg z-50">
                    <div className="font-black text-xl flex items-center gap-2"><ArrowRight className="text-yellow-400"/> MULTIVERSE RUN</div>
                    
                    {/* TOGGLE STAFFETTA */}
                    {currentRoom?.gameMode === 'relay' && isLeader && view === 'game' && (
                        <button onClick={toggleBotMode} className="bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg text-xs font-black border border-white/50 flex items-center gap-2 transition-colors">
                            <Bot size={16}/> 
                            <span>BOT: {currentRoom.teamBotModes?.[me.teamId] === 'manual' ? 'MANUALE' : 'AUTO'}</span>
                        </button>
                    )}

                    {currentRoom && view !== 'game' && <div className="font-mono bg-indigo-800 px-2 py-1 rounded text-xs flex items-center gap-2"><span>ROOM: {currentRoom.code}</span></div>}
                    {view !== 'menu' && <button onClick={() => { setView('menu'); setRoomCode(''); }}><LogOut size={20}/></button>}
                </div>

                <div className={`fixed top-16 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-2 rounded-full shadow-2xl transition-all duration-300 z-50 font-bold border border-slate-600 ${notif ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-10 pointer-events-none'}`}>{notif}</div>

                <div className="flex-1 flex overflow-hidden">
                    <div className="flex-1 overflow-y-auto p-4 flex flex-col items-center">
                        {view === 'menu' && (
                        <div className="max-w-md w-full mt-10 space-y-6">
                            <div className="text-center"><h1 className="text-4xl font-black text-indigo-900 mb-2">MULTIVERSE RUN</h1><p className="text-slate-500 font-bold uppercase tracking-widest text-xs">Arcade Edition</p></div>
                            <input type="text" placeholder="Nickname" className="w-full p-4 text-center text-xl font-black rounded-xl border-4 border-indigo-100 outline-none" value={nickname} onChange={e=>setNickname(e.target.value)} />
                            <div className="grid grid-cols-2 gap-2">
                                <button onClick={() => createRoom('classic')} disabled={!nickname} className="h-24 bg-green-500 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Flag className="mx-auto mb-1"/> CLASSICA</button>
                                <button onClick={() => createRoom('classic_punitive')} disabled={!nickname} className="h-24 bg-rose-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Swords className="mx-auto mb-1"/> PUNITIVA</button>
                                <button onClick={() => createRoom('elimination')} disabled={!nickname} className="h-24 bg-cyan-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Skull className="mx-auto mb-1"/> ELIMINAZIONE</button>
                                <button onClick={() => createRoom('infection')} disabled={!nickname} className="h-24 bg-lime-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Biohazard className="mx-auto mb-1"/> INFEZIONE</button>
                                <button onClick={() => createRoom('lava')} disabled={!nickname} className="h-24 bg-orange-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Flame className="mx-auto mb-1"/> LAVA</button>
                                <button onClick={() => createRoom('gem_hunt')} disabled={!nickname} className="h-24 bg-indigo-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Gem className="mx-auto mb-1"/> CACCIA ALLE GEMME</button>
                                <button onClick={() => createRoom('raid_boss')} disabled={!nickname} className="h-24 bg-red-900 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all col-span-2 border-2 border-red-500"><Crown className="mx-auto mb-1"/> RAID BOSS</button>
                                <button onClick={() => createRoom('black_hole')} disabled={!nickname} className="h-24 bg-black rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all col-span-2 border-2 border-purple-500"><Disc className="mx-auto mb-1"/> BUCO NERO</button>
                            </div>
                            <button onClick={() => nickname && setView('relay_setup')} disabled={!nickname} className="w-full py-3 bg-blue-600 rounded-xl text-white font-black shadow-lg flex flex-col items-center"><Users size={20}/> STAFFETTA</button>
                            <div className="flex gap-2"><input id="codeIn" type="text" placeholder="CODICE" className="flex-1 p-3 rounded-xl border-2 font-black text-center uppercase"/><button onClick={() => joinRoom(document.getElementById('codeIn').value)} disabled={!nickname} className="px-6 bg-slate-800 text-white font-black rounded-xl uppercase text-xs">Entra</button></div>
                        </div>
                        )}

                        {view === 'relay_setup' && (
                            <div className="max-w-md w-full mt-10 space-y-6 bg-white p-6 rounded-2xl shadow-xl border-4 border-indigo-100">
                                <h2 className="text-2xl font-black text-center text-indigo-900">CONFIGURA STAFFETTA</h2>
                                <div><label className="block font-black text-slate-400 mb-2 uppercase text-xs">Numero Team</label><div className="flex gap-2">{[2,3,4].map(n => (<button key={n} onClick={() => setRelayConfig({...relayConfig, teams: n})} className={`flex-1 py-3 rounded-lg font-black ${relayConfig.teams === n ? 'bg-indigo-600 text-white' : 'bg-slate-100'}`}>{n}</button>))}</div></div>
                                <div><label className="block font-black text-slate-400 mb-2 uppercase text-xs">Corridori per Team</label><div className="flex gap-2">{[2,3,4].map(n => (<button key={n} onClick={() => setRelayConfig({...relayConfig, size: n})} className={`flex-1 py-3 rounded-lg font-black ${relayConfig.size === n ? 'bg-indigo-600 text-white' : 'bg-slate-100'}`}>{n}</button>))}</div></div>
                                <button onClick={() => createRoom('relay')} className="w-full py-4 bg-green-500 text-white font-black text-xl rounded-xl shadow-lg">CREA</button>
                            </div>
                        )}

                        {view === 'lobby' && currentRoom && (
                        <div className="w-full max-w-6xl space-y-6">
                            <div className="bg-white p-6 rounded-2xl shadow-sm border flex justify-between items-center gap-4">
                                <div><h2 className="text-2xl font-black text-indigo-900 uppercase">{currentRoom.gameMode.replace('_', ' ')}</h2></div>
                                {currentRoom.hostId === user.uid && <div className="flex gap-2"><button onClick={addBot} className="bg-slate-200 px-4 py-2 rounded-lg font-black text-xs uppercase">Add Bot</button><button onClick={startGame} className="bg-green-500 text-white px-8 py-2 rounded-lg font-black shadow-lg">START</button></div>}
                            </div>
                            
                            {/* Player List Panel - DYNAMIC FOR RELAY */}
                            {currentRoom.gameMode === 'relay' ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    {Array.from({ length: currentRoom.teamConfig.teams }).map((_, teamIdx) => {
                                        const teamPlayers = currentRoom.players.filter(p => p.teamId === teamIdx);
                                        const teamHumanPlayers = teamPlayers.filter(p => !p.isBot);
                                        const isMyTeam = currentRoom.players.find(p => p.uid === user.uid)?.teamId === teamIdx;
                                        // Team Leader is first human in the team list
                                        const teamLeader = teamHumanPlayers.length > 0 ? teamHumanPlayers[0].uid : null;
                                        const amILeader = teamLeader === user.uid;
                                        
                                        return (
                                            <div key={teamIdx} className={`bg-white rounded-2xl shadow-md overflow-hidden border-t-8 ${TEAM_COLORS[teamIdx].border}`}>
                                                <div className={`p-3 ${TEAM_COLORS[teamIdx].light} flex justify-between items-center`}>
                                                    <h3 className={`font-black uppercase ${TEAM_COLORS[teamIdx].text}`}>TEAM {teamIdx + 1}</h3>
                                                    {amILeader && (
                                                        <button onClick={() => toggleBotModeLobby(teamIdx)} className="flex items-center gap-1 bg-white/50 hover:bg-white px-2 py-1 rounded text-[10px] font-bold border border-black/5 transition-colors">
                                                            <Bot size={12}/> {currentRoom.teamBotModes?.[teamIdx] === 'manual' ? 'MANUALE' : 'AUTO'}
                                                        </button>
                                                    )}
                                                </div>
                                                <div className="p-3 space-y-2 max-h-60 overflow-y-auto">
                                                    {teamPlayers.map(p => (
                                                        <div key={p.uid} className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg border">
                                                            <PlayerAvatar charId={p.characterId} size="sm"/>
                                                            <div className="flex-1 min-w-0">
                                                                <div className="font-bold text-sm truncate flex items-center gap-2">
                                                                    {p.name} 
                                                                    {p.isBot && <span className="text-[10px] bg-slate-200 px-1 rounded text-slate-500">BOT</span>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                    {teamPlayers.length === 0 && <div className="text-center text-xs text-slate-400 py-4 italic">Nessun giocatore</div>}
                                                </div>
                                                {!isMyTeam && (
                                                    <div className="p-2 border-t bg-slate-50">
                                                        <button onClick={() => switchTeam(teamIdx)} className="w-full py-2 bg-white border-2 hover:bg-slate-100 rounded-lg text-xs font-black uppercase flex items-center justify-center gap-2 transition-colors">
                                                            <Move size={14}/> Unisciti
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="flex flex-col md:flex-row gap-4">
                                    <div className="w-full md:w-1/3 bg-white p-4 rounded-2xl shadow-sm border h-fit max-h-96 overflow-y-auto">
                                         <h3 className="font-black text-indigo-900 mb-2 flex items-center gap-2 text-sm uppercase"><Users size={16}/> Giocatori ({currentRoom.players.length})</h3>
                                         <div className="space-y-2">
                                            {currentRoom.players.map(p => (
                                                <div key={p.uid} className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg border">
                                                    <PlayerAvatar charId={p.characterId} size="sm"/>
                                                    <div className="flex-1 min-w-0">
                                                        <div className="font-bold text-sm truncate flex items-center gap-2">
                                                            {p.name} 
                                                            {p.isBot && <span className="text-[10px] bg-slate-200 px-1 rounded text-slate-500">BOT</span>}
                                                        </div>
                                                        <div className="text-[10px] text-slate-400 uppercase font-bold">{ROSTER[p.characterId].name}</div>
                                                    </div>
                                                    {p.uid === currentRoom.hostId && <Crown size={14} className="text-yellow-500"/>}
                                                    {currentRoom.gameMode === 'lava' && p.lives !== undefined && (
                                                        <div className="flex items-center gap-0.5 text-red-500 font-black text-xs">
                                                            <Heart size={12} className="fill-current"/> x {p.lives}
                                                        </div>
                                                    )}
                                                    {currentRoom.gameMode === 'raid_boss' && (
                                                        <div className="flex items-center gap-0.5 font-black text-xs">
                                                            {p.uid === currentRoom.hostId ? <span className="text-red-700 bg-red-100 px-1 rounded">BOSS</span> : <span className="text-blue-700 bg-blue-100 px-1 rounded flex items-center gap-1"><Heart size={10} className="fill-current"/> {p.lives}</span>}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                         </div>
                                    </div>
                                    
                                    <div className="flex-1">
                                        <div className="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-2">
                                            {ROSTER.map(c => {
                                                const taken = currentRoom.players.some(p => p.characterId === c.id);
                                                const mine = currentRoom.players.find(p => p.uid === user.uid)?.characterId === c.id;
                                                return (<button key={c.id} onClick={() => selectChar(c.id)} disabled={taken && !mine} className={`relative aspect-[3/4] rounded-xl overflow-hidden transition-all bg-slate-100 ${mine ? 'ring-4 ring-indigo-500 scale-105 z-10' : ''} ${taken && !mine ? 'grayscale opacity-50' : ''}`}><img src={c.img} className="w-full h-full object-cover"/><div className={`absolute bottom-0 w-full text-[8px] p-1 font-black text-white ${c.dice.color}`}>{c.dice.name}</div></button>)
                                            })}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Character Selector moved below for relay mode to allow more width for teams */}
                            {currentRoom.gameMode === 'relay' && (
                                <div className="mt-6">
                                    <h3 className="font-black text-indigo-900 mb-2 flex items-center gap-2 text-sm uppercase"><User size={16}/> Scegli Personaggio</h3>
                                    <div className="grid grid-cols-3 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                        {ROSTER.map(c => {
                                            const taken = currentRoom.players.some(p => p.characterId === c.id);
                                            const mine = currentRoom.players.find(p => p.uid === user.uid)?.characterId === c.id;
                                            return (<button key={c.id} onClick={() => selectChar(c.id)} disabled={taken && !mine} className={`relative aspect-[3/4] rounded-xl overflow-hidden transition-all bg-slate-100 ${mine ? 'ring-4 ring-indigo-500 scale-105 z-10' : ''} ${taken && !mine ? 'grayscale opacity-50' : ''}`}><img src={c.img} className="w-full h-full object-cover"/><div className={`absolute bottom-0 w-full text-[8px] p-1 font-black text-white ${c.dice.color}`}>{c.dice.name}</div></button>)
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                        )}

                        {view === 'game' && currentRoom && currentPlayer && (
                        <div className="w-full max-w-5xl flex flex-col gap-4">
                            <div className="flex items-center justify-between bg-white p-3 rounded-xl shadow-sm border sticky top-0 z-40">
                                <div className="flex items-center gap-3">
                                    <div className="text-center"><div className="text-[10px] text-slate-400 font-black uppercase tracking-widest">Turno</div><div className="font-black text-indigo-900 leading-none">{currentPlayer.name}</div></div>
                                    <PlayerAvatar charId={currentPlayer.characterId}/>
                                    {currentRoom.gameMode === 'lava' && currentPlayer.lives !== undefined && (
                                         <div className="flex items-center gap-1 bg-red-100 text-red-600 px-2 py-1 rounded-lg border border-red-200">
                                            <Heart size={16} className="fill-current"/> <span className="font-black text-lg">{currentPlayer.lives}</span>
                                         </div>
                                    )}
                                    {currentRoom.gameMode === 'raid_boss' && (
                                        <div className="flex items-center gap-2">
                                            {currentPlayer.uid === currentRoom.hostId ? 
                                                <div className="bg-red-900 text-white px-3 py-1 rounded-lg font-black flex items-center gap-1"><Crown size={14}/> BOSS ({currentRoom.bossHp} HP)</div> 
                                                : 
                                                <div className="bg-blue-100 text-blue-700 px-3 py-1 rounded-lg font-black flex items-center gap-1"><Heart size={14} className="fill-current"/> {currentPlayer.lives} VITE</div>
                                            }
                                        </div>
                                    )}
                                </div>
                                <div className="text-right">
                                    <div className="text-[10px] text-slate-400 font-black uppercase tracking-widest">{currentRoom.gameMode.toUpperCase().replace('_', ' ')}</div>
                                    <div className="font-black text-indigo-900 leading-none">ROUND {currentRoom.round}</div>
                                </div>
                            </div>

                            <div className="grid grid-cols-5 md:grid-cols-8 lg:grid-cols-10 gap-1.5 p-2 bg-slate-200/50 rounded-xl">
                                {Array.from({ length: (currentRoom.gameMode === 'elimination' ? 34 : (currentRoom.gameMode === 'gem_hunt' ? 50 : 60)) + 1 }).map((_, i) => (
                                    <BoardCell key={i} num={i} players={currentRoom.players.filter(p => p.position === i && !p.isDead)} special={(currentRoom.gameMode === 'elimination' ? (currentRoom.customSpecials?.[i] || ELIM_MAP.specials[i]) : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP.specials[i] : CLASSIC_MAP.specials[i]))} isElimination={currentRoom.gameMode === 'elimination'} isPendingTarget={currentPlayer.uid === user.uid && currentPlayer.pendingTarget === i} onCellClick={targetSelectionMode ? () => {} : () => executeMove(user.uid, i)} onInfoClick={(s) => setSelectedCellInfo(s)} gems={currentRoom.gemLocations} infected={currentRoom.infectedNPC} isTargetSelection={false} lavaTiles={currentRoom.lavaTiles} blackHolePos={currentRoom.blackHolePos} bossTargetUid={currentRoom.bossTargetUid} />
                                ))}
                            </div>

                            <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-40 w-full max-w-sm px-4">
                                {currentRoom.status === 'finished' ? (
                                    <div className="bg-indigo-900 text-white p-6 rounded-2xl shadow-2xl text-center border-4 border-yellow-400 animate-bounce-slow"><Trophy size={48} className="mx-auto text-yellow-400 mb-2"/><h2 className="text-3xl font-black uppercase">Vittoria!</h2><p className="text-xl font-bold opacity-90">{currentRoom.winner}</p><button onClick={() => { setView('menu'); setRoomCode(''); }} className="mt-4 bg-white text-indigo-900 px-6 py-2 rounded-full font-black uppercase text-xs">Menu</button></div>
                                ) : (
                                    <div className="space-y-2">
                                        {canControlCurrent && lastRoll !== null && !isRolling && !directionChoice && !decisionMode && (
                                            <div className="bg-white/90 backdrop-blur-sm border-2 border-indigo-500 text-indigo-900 rounded-xl p-2 text-center shadow-lg animate-in slide-in-from-bottom-2">
                                                <div className="text-[10px] font-black uppercase tracking-widest opacity-60">Hai fatto</div>
                                                <div className="text-3xl font-black leading-none">{lastRoll}</div>
                                            </div>
                                        )}
                                        
                                        {directionChoice && canControlCurrent && (
                                            <div className="bg-white p-4 rounded-2xl shadow-2xl border-4 border-indigo-500 animate-bounce flex flex-col items-center gap-4"><h3 className="font-black text-indigo-900 uppercase">Scegli Direzione: {directionChoice.val}</h3><div className="flex gap-4 w-full"><button onClick={() => confirmGemMove(-1)} className="flex-1 bg-red-500 text-white py-3 rounded-xl font-black uppercase flex flex-col items-center"><ArrowLeft/> Indietro</button><button onClick={() => confirmGemMove(1)} className="flex-1 bg-green-500 text-white py-3 rounded-xl font-black uppercase flex flex-col items-center"><ArrowRight/> Avanti</button></div></div>
                                        )}
                                        {!directionChoice && !decisionMode && !bossTargetSelection && (
                                            <button onClick={handleRoll} disabled={isRolling || isMoving || !canControlCurrent || currentPlayer.pendingTarget !== null} className={`w-full py-4 rounded-2xl font-black text-2xl shadow-xl transition-all flex items-center justify-center gap-3 border-b-8 active:translate-y-2 active:border-b-0 ${isRolling || isMoving ? 'bg-slate-300 border-slate-400' : (canControlCurrent ? 'bg-orange-500 text-white border-orange-700' : 'bg-slate-100 text-slate-300 border-slate-200')}`}>{isRolling ? <Dice5 className="animate-spin"/> : <Dice5/>} <span>{isRolling ? "..." : (currentPlayer.pendingTarget !== null ? "CLICCA LA CASELLA!" : (currentPlayer.activeCurse ? "MALEDETTO!" : "TIRA DADO"))}</span></button>
                                        )}
                                        {canControlCurrent && currentPlayer.pendingTarget === null && !directionChoice && !decisionMode && !currentPlayer.activeCurse && !bossTargetSelection && (
                                            <div className="bg-white p-3 rounded-xl shadow-lg border-2 flex flex-col gap-2 animate-in slide-in-from-bottom-4 fade-in duration-500">
                                                <div className="flex justify-between items-end">
                                                     <div className="text-[10px] font-black text-slate-400 uppercase mb-1">{currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? "DADO BOSS" : "Probabilità"}</div>
                                                </div>
                                                <div className="flex justify-between gap-1">
                                                    {(currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? BOSS_DICE_VALS : ROSTER[currentPlayer.characterId].dice.vals).map((v, i) => (
                                                        <div key={i} className={`flex-1 aspect-square flex items-center justify-center rounded-lg border-2 font-black text-sm transition-all ${currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? 'text-red-500 bg-red-50 border-red-200' : (useSpecialDie ? `${ROSTER[currentPlayer.characterId].dice.text} border-current bg-white shadow-sm` : 'text-slate-300 border-slate-100 bg-slate-50')}`}>
                                                            {v}
                                                        </div>
                                                    ))}
                                                </div>
                                                {!(currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId) && (
                                                <>
                                                    <div className="h-px bg-slate-100 my-1"></div>
                                                    <div className="flex justify-between items-center">
                                                        <div className="flex flex-col">
                                                            <span className="text-[10px] font-black text-slate-400 uppercase leading-none">Usa Dado Speciale</span>
                                                            <span className={`font-black ${ROSTER[currentPlayer.characterId].dice.text}`}>{ROSTER[currentPlayer.characterId].dice.name}</span>
                                                        </div>
                                                        <button onClick={() => setUseSpecialDie(!useSpecialDie)} className={`px-4 py-2 rounded-xl font-black text-xs transition-all ${useSpecialDie ? 'bg-indigo-900 text-white shadow-lg scale-105' : 'bg-slate-100 text-slate-400'}`}>{useSpecialDie ? 'ON' : 'OFF'}</button>
                                                    </div>
                                                </>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                        )}
                    </div>

                    {view === 'game' && currentRoom && (
                        <div className="hidden lg:flex flex-col w-80 bg-indigo-950 text-white border-l-4 border-white/10 overflow-y-auto p-4 space-y-3">
                            <h3 className="font-black text-lg border-b border-white/10 pb-2 flex items-center gap-2"><Trophy size={20} className="text-yellow-400"/> CLASSIFICA</h3>
                            {[...currentRoom.players].sort((a,b) => {
                                if (a.finished && !b.finished) return -1;
                                if (!a.finished && b.finished) return 1;
                                if (a.finished && b.finished) return (a.rank || 0) - (b.rank || 0);
                                if (currentRoom.gameMode === 'gem_hunt') return (b.collectedGems?.length||0) - (a.collectedGems?.length||0);
                                return b.position - a.position;
                            }).map((p, i) => (
                                <div key={p.id} onClick={() => targetSelectionMode && handleTargetClick(p.uid)} className={`p-3 rounded-xl border-2 flex items-center gap-3 transition-all ${p.uid === user.uid ? 'bg-white/10 border-indigo-400' : 'bg-black/20 border-transparent'} ${targetSelectionMode ? 'cursor-pointer hover:border-red-500 hover:bg-white/5' : ''}`}>
                                    <div className="font-black text-white/40 w-6">{p.finished ? '🏁' : `${i+1}°`}</div>
                                    <PlayerAvatar charId={p.characterId} size="sm"/>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-black text-sm truncate">{p.name}</div>
                                        <div className="text-[10px] font-bold text-white/50 uppercase">
                                            {p.finished ? 'Arrivato' : `Casella ${p.position}`} {p.activeCurse && "• Maledetto"}
                                            {currentRoom.gameMode === 'gem_hunt' && ` • Gemme: ${p.collectedGems?.length || 0}/5`}
                                            {currentRoom.gameMode === 'lava' && ` • Vite: ${p.lives}`}
                                            {currentRoom.gameMode === 'raid_boss' && (p.uid === currentRoom.hostId ? ` • Boss HP: ${currentRoom.bossHp}` : ` • Vite: ${p.lives}`)}
                                        </div>
                                    </div>
                                    {currentRoom.gameMode === 'raid_boss' && p.uid === currentRoom.bossTargetUid && <Crosshair className="text-red-500 animate-pulse"/>}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>