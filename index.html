<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiverse Run: Arcade</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @keyframes bounce-slow {
            0%, 100% { transform: translateY(-5%); }
            50% { transform: translateY(5%); }
        }
        .animate-bounce-slow {
            animation: bounce-slow 2s infinite;
        }
        .gem-glow {
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
        }
        .coin-glow-3 { filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.9)); }
        .coin-glow-2 { filter: drop-shadow(0 0 4px rgba(192, 192, 192, 0.9)); }
        .coin-glow-1 { filter: drop-shadow(0 0 3px rgba(205, 127, 50, 0.9)); }

        .black-hole-bg {
            background: repeating-linear-gradient(
                45deg,
                #000,
                #000 10px,
                #1e1b4b 10px,
                #1e1b4b 20px
            );
        }
        /* Custom scrollbar */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Glitch Effect */
        @keyframes glitch-anim {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }
        .glitch-text {
            animation: glitch-anim 0.3s infinite;
            color: #0f0;
            text-shadow: 2px 0 #f0f, -2px 0 #0ff;
        }

        /* Void Tile Animation */
        .void-tile {
            background-color: #0f172a;
            opacity: 0.8;
            background-image: radial-gradient(#1e293b 1px, transparent 1px);
            background-size: 10px 10px;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Dice5, LogOut, ArrowRight, Skull, RefreshCcw, 
            ArrowUp, ArrowDown, Footprints, Crown, Trophy, 
            Zap, Bomb, Flag, Flame, Ghost, ShieldAlert, Pointer, Dices, Info, Medal, User, X, ChevronsUp, Users, Shield, AlertCircle, Shuffle, Gem, Biohazard, ArrowLeft, Swords,
            Gavel, ArrowLeftRight, Sparkles, Ban, MousePointer2, Target, Heart, Crosshair, Disc, Bot, Move, Grid3X3, Palette, Timer, Siren, Rewind, Swords as SwordsIcon, Coins,
            Lock, Activity, MousePointerClick, Crosshair as Scope, Bug, List, Hash, Dice1, Dice2, Dice3, Dice4, Dice6, Anchor, Droplets, Hand, SkipForward, Gauge, TrendingDown
        } from 'lucide-react';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken,
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            arrayUnion 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyDTaGJcSOVHg3_2K5SgcrDfANtdn0ewb6s",
            authDomain: "gioco-oca-pincher.firebaseapp.com",
            projectId: "gioco-oca-pincher",
            storageBucket: "gioco-oca-pincher.firebasestorage.app",
            messagingSenderId: "41567402648",
            appId: "1:41567402648:web:292e0567e58e814276aeed",
            measurementId: "G-RCF5K88KPN"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const appId = 'multiverse_goose_game_v2'; 

        const TEAM_COLORS = [
            { name: "Rosso", bg: "bg-red-500", border: "border-red-500", text: "text-red-500", light: "bg-red-50", ring: "ring-red-500" },
            { name: "Blu", bg: "bg-blue-500", border: "border-blue-500", text: "text-blue-500", light: "bg-blue-50", ring: "ring-blue-500" },
            { name: "Verde", bg: "bg-green-500", border: "border-green-500", text: "text-green-500", light: "bg-green-50", ring: "ring-green-500" },
            { name: "Giallo", bg: "bg-yellow-500", border: "border-yellow-500", text: "text-yellow-600", light: "bg-yellow-50", ring: "ring-yellow-500" }
        ];

        const PAINT_COLORS = ["#ef4444", "#f97316", "#f59e0b", "#eab308", "#84cc16", "#22c55e", "#10b981", "#14b8a6", "#06b6d4", "#0ea5e9", "#3b82f6", "#6366f1", "#8b5cf6", "#a855f7", "#d946ef", "#ec4899", "#f43f5e", "#78716c", "#57534e", "#1e293b"];

        const ROSTER = [
            { name: "Marinette", img: "https://i.pinimg.com/736x/b8/74/55/b87455575cd069609007a639c9490293.jpg", dice: { name: "Dado Fortunato", vals: [2, 2, 2, 4, 4, 7], color: "bg-pink-500", text: "text-pink-500", desc: "Niente rischi, solo progressi costanti." } },
            { name: "Adrien", img: "https://i.pinimg.com/1200x/5c/2d/c7/5c2dc740ed2fe906b6afaf1320bf4273.jpg", dice: { name: "Dado Cataclisma", vals: [-2, -1, 3, 6, 6, 9], color: "bg-gray-800", text: "text-gray-800", desc: "Estremi pericolosi: o voli o crolli." } },
            { name: "Re Julien", img: "https://i.pinimg.com/736x/1e/17/19/1e17194ef5b383e4202fbb4875cfbd81.jpg", dice: { name: "Dado da Re", vals: [2, 2, 2, 4, 4, 4], color: "bg-yellow-500", text: "text-yellow-500", desc: "Un re non corre, incede con grazia." } },
            { name: "Gwen", img: "https://i.pinimg.com/1200x/59/d7/15/59d71578cd5f889ae898bbc83dda29dc.jpg", dice: { name: "Dado Solitario", vals: [3, 3, 3, 3, 3, 3], color: "bg-teal-600", text: "text-teal-600", desc: "La coerenza è la chiave della vittoria." } },
            { name: "Heather", img: "https://i.pinimg.com/736x/81/5b/b6/815bb632721e7d38f26d35801466dd30.jpg", dice: { name: "Dado Villain", vals: [-1, 1, 2, 2, 6, 8], color: "bg-purple-800", text: "text-purple-800", desc: "Pianifica, indietreggia, colpisci duro." } },
            { name: "Lindsay", img: "https://i.pinimg.com/1200x/ed/96/df/ed96df179eaa7030663473c575067cb4.jpg", dice: { name: "Dado Stupido", vals: [-6, 0, 0, 2, 10, 10], color: "bg-orange-300", text: "text-orange-500", desc: "O disastro totale o miracolo assoluto." } },
            { name: "Yoshi", img: "https://i.pinimg.com/736x/f3/05/7f/f3057f14de68b0afe682ffe93dcc479b.jpg", dice: { name: "Dado Uovo", vals: [2, 2, 2, 3, 7, 8], color: "bg-green-500", text: "text-green-500", desc: "A volte cova (0), a volte scatta!" } },
            { name: "Wario", img: "https://i.pinimg.com/736x/2f/ea/be/2feabe47151fd436fbf358c299eb4870.jpg", dice: { name: "Dado WAH?", vals: [0, 0, 1, 2, 7, 8], color: "bg-yellow-600", text: "text-yellow-700", desc: "Pigrizia o avidità, niente vie di mezzo." } },
            { name: "Tanjiro", img: "https://i.pinimg.com/736x/e9/6d/20/e96d20e7c159897a05c6baa57fac7f35.jpg", dice: { name: "Dado d'Acqua", vals: [0, 1, 2, 5, 6, 7], color: "bg-cyan-500", text: "text-cyan-600", desc: "Fluido come l'acqua, a volte calmo a volte impetuoso." } },
            { name: "Mr Krab", img: "https://i.pinimg.com/1200x/74/9c/f5/749cf53dd48dbb440fcde8d958c7dbb1.jpg", dice: { name: "Dado Greedy", vals: [-2, -2, 3, 3, 8, 8], color: "bg-red-600", text: "text-red-600", desc: "Rischia tutto per il malloppo grosso." } },
            { name: "Gumball", img: "https://i.pinimg.com/736x/ae/88/e3/ae88e329120b3edc196af1ebbfd8fe07.jpg", dice: { name: "Dado Caotico", vals: [0, 0, 0, 6, 6, 6], color: "bg-blue-400", text: "text-blue-500", desc: "Tutto o niente: o stai fermo o voli!" } },
            { name: "Johnny Bravo", img: "https://i.pinimg.com/736x/4a/62/70/4a6270678f7adcf130672bcd0af41fdf.jpg", dice: { name: "Dado Oh Yeah", vals: [0, 0, 1, 6, 7, 8], color: "bg-black", text: "text-black", desc: "Fatti bello e spera nel meglio." } },
            { name: "Steven", img: "https://i.pinimg.com/736x/2b/fd/20/2bfd202ab782611ea6a0fb0cdcdc37ab.jpg", dice: { name: "Dado Diamantato", vals: [1, 1, 1, 4, 5, 6], color: "bg-pink-300", text: "text-pink-400", desc: "Lento e protettivo, ma sicuro." } },
            { name: "Ariana Grande", img: "https://media.tenor.com/1u94p6qR01gAAAAM/ariana-grande-eternal-sunshine.gif", dice: { name: "Dado YUH", vals: [0, 0, 1, 5, 6, 8], color: "bg-indigo-300", text: "text-indigo-400", desc: "Note alte e passi lunghi (se canti)." } },
            { name: "Will", img: "https://i.pinimg.com/originals/88/80/73/8880736b5695844044e0e38c8063a1ff.gif", dice: { name: "Dado Rainbow", vals: [3, 3, 3, 3, 3, 6], color: "bg-indigo-500", text: "text-indigo-500", desc: "Costante con un tocco di favolosità." } },
            { name: "Carlos Oliveira", img: "https://i.pinimg.com/originals/32/0d/d1/320dd13031f1aba8a2d3d9b9837174f4.gif", dice: { name: "Dado Peloso", vals: [-2, 0, 2, 4, 6, 8], color: "bg-orange-800", text: "text-orange-800", desc: "Selvaggio e imprevedibile." } },
            { name: "Leon", img: "https://i.pinimg.com/736x/db/ef/fc/dbeffc6e915a929f7dbe908390f5af42.jpg", dice: { name: "Dado Carismatico", vals: [2, 2, 2, 5, 5, 5], color: "bg-blue-800", text: "text-blue-800", desc: "Solo numeri stilosi." } },
            { name: "Finn", img: "https://i.pinimg.com/736x/7e/0b/c9/7e0bc9826a7652264f32a44bc8a40ede.jpg", dice: { name: "Dado Cauto", vals: [1, 1, 1, 1, 1, 9], color: "bg-blue-300", text: "text-blue-400", desc: "Un passo alla volta, eroe." } },
            { name: "Jake", img: "https://i.pinimg.com/1200x/cd/77/22/cd7722b2f98ffc75d1128913df6861d7.jpg", dice: { name: "Dado Rischioso", vals: [-3, -2, -1, 7, 9, 10], color: "bg-yellow-400", text: "text-yellow-600", desc: "Allungati troppo e torni indietro." } },
            { name: "Stewie", img: "https://i.pinimg.com/1200x/1e/a2/cc/1ea2cc7a197e3841086f4a1ce18b089c.jpg", dice: { name: "Genio del Male", vals: [1, 3, 5, 6, 7, 7], color: "bg-red-500", text: "text-red-500", desc: "Piani complessi per grandi risultati." } },
            { name: "Peter", img: "https://i.pinimg.com/736x/9e/40/74/9e4074bbe7890cd245b51b9ff5c0e33c.jpg", dice: { name: "Dado Affamato", vals: [1, 2, 2, 2, 7, 8], color: "bg-green-600", text: "text-green-700", desc: "Corri verso il buffet." } },
            { name: "Ashley", img: "https://i.pinimg.com/736x/d1/c5/5f/d1c55f57218baecf0c2e160155e80c61.jpg", dice: { name: "Dado Ti Amo", vals: [3, 3, 3, 3, 3, 3], color: "bg-red-400", text: "text-red-400", desc: "Amore costante e ripetitivo." } },
            { name: "Nicole", img: "https://i.pinimg.com/736x/81/24/e4/8124e43da43e1d06dcdbca15f22a0cd9.jpg", dice: { name: "Dado Materno", vals: [0, 0, 2, 5, 5, 5], color: "bg-blue-500", text: "text-blue-600", desc: "Severa ma giusta." } },
            { name: "Lapis", img: "https://i.pinimg.com/1200x/09/fb/12/09fb12467957da96913fc8f75e6f6356.jpg", dice: { name: "Dado Tsunami", vals: [-4, -2, 0, 6, 8, 10], color: "bg-blue-600", text: "text-blue-600", desc: "La forza dell'oceano: devastante o ritirata." } },
            { name: "Jake (DC)", img: "https://i.pinimg.com/736x/bc/a0/76/bca0765eaa0f1e88b0070a5b92c22de7.jpg", dice: { name: "Dado Twink", vals: [-1, 0, 1, 4, 9, 9], color: "bg-pink-400", text: "text-pink-500", desc: "Delicato ma capace di esplodere." } },
            { name: "Tom", img: "https://i.pinimg.com/736x/fb/da/0a/fbda0a5f373f173a17726271e423f953.jpg", dice: { name: "Dado Spia", vals: [1, 2, 4, 4, 6, 7], color: "bg-slate-700", text: "text-slate-700", desc: "Calcolato, preciso e letale." } },
            { name: "Gabby", img: "https://i.pinimg.com/736x/a2/14/9c/a2149c917938c8460be43aca06945173.jpg", dice: { name: "Dado Schizo", vals: [-2, -1, 4, 4, 4, 5], color: "bg-purple-500", text: "text-purple-600", desc: "Caos totale: retromarcia o scatto." } },
            { name: "Po", img: "https://i.pinimg.com/1200x/fb/99/a5/fb99a5c7ce5b313ed1c4e71ee0260a9b.jpg", dice: { name: "Dado Guerriero", vals: [1, 2, 5, 7], color: "bg-red-600", text: "text-red-700", desc: "La via del guerriero è essenziale." } },
            { name: "Francine", img: "https://i.pinimg.com/736x/b3/b5/f6/b3b5f6849a52b4daed92424650a98f7f.jpg", dice: { name: "Dado Baddie", vals: [-1, -1, 4, 4, 4, 4], color: "bg-rose-500", text: "text-rose-500", desc: "Cattiva ma con stile." } },
            { name: "Carrie", img: "https://i.pinimg.com/736x/b7/4b/cf/b74bcfa3fe7236c9ba3ab7af9a34bcea.jpg", dice: { name: "Dado Fantasma", vals: [-3, 3, 3, 3, 4, 5], color: "bg-zinc-500", text: "text-zinc-500", desc: "Spettrale e imprevedibile." } },
            { name: "Gommarosa", img: "https://i.pinimg.com/1200x/08/55/4e/08554e6bf4a3f93069db83fa67ca11c7.jpg", dice: { name: "Dado Gommoso", vals: [2, 2, 2, 4, 4, 9], color: "bg-pink-400", text: "text-pink-400", desc: "Dolce e appiccicosa." } },
            { name: "Marceline", img: "https://i.pinimg.com/1200x/bd/81/67/bd816740842afa6514f3246c38a32bd8.jpg", dice: { name: "Dado Vampirico", vals: [-1, 4, 8, 1, 4, 8], color: "bg-slate-900", text: "text-slate-800", desc: "Morsi potenti o ritiro nell'ombra." } },
            { name: "Toph", img: "https://i.pinimg.com/736x/cf/26/2e/cf262e1acee23fe4dadd852dda3a71d1.jpg", dice: { name: "Dado Cieco", vals: [-3, -3, -1, 3, 5, 13], color: "bg-stone-600", text: "text-stone-700", desc: "Non vede, ma quando colpisce fa male." } },
            { name: "Fiamma", img: "https://i.pinimg.com/1200x/30/98/43/309843f2f301f59c19ad95dc366fa93b.jpg", dice: { name: "Dado Fiammante", vals: [1, 2, 3, 4, 5, 9], color: "bg-orange-500", text: "text-orange-500", desc: "Un dado normale... finché non divampa!" } },
            { name: "Re Dado", img: "https://i.pinimg.com/736x/d7/68/ae/d768ae090345733da8b98eac071e3873.jpg", dice: { name: "Dado Master", vals: [1, 1, 3, 4, 6, 6], color: "bg-purple-600", text: "text-purple-600", desc: "Gioco d'azzardo controllato dal Boss." } },
            { name: "Yugo", img: "https://i.pinimg.com/736x/cc/fa/6d/ccfa6d56145da782cd6a250ce19254a3.jpg", dice: { name: "Dado Wakfu", vals: [0, 2, 4, 4, 7, 8], color: "bg-cyan-500", text: "text-cyan-600", desc: "Portali energetici: salti rapidi e precisi." } }
        ].map((c, i) => ({ ...c, id: i }));

        const BOSS_DICE_VALS = [3, 4, 5, 6, 7, 8];
        const TOURNAMENT_POINTS = [10, 8, 6, 5, 4, 3, 2, 1];

        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                const now = ctx.currentTime;
                if (type === 'click') { osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'step') { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'gem') { osc.type = 'sine'; osc.frequency.setValueAtTime(1000, now); osc.frequency.linearRampToValueAtTime(2000, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'zombie') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5); gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'teleport') { osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.2); osc.frequency.exponentialRampToValueAtTime(100, now + 0.4); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.4); osc.start(now); osc.stop(now + 0.4); }
                else if (type === 'punch') { osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.1); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'curse') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'fire') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.3); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'boss_hit') { osc.type = 'square'; osc.frequency.setValueAtTime(80, now); gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 0.2); osc.start(now); osc.stop(now + 0.2); }
                else if (type === 'suck') { osc.type = 'sine'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(0, now + 1); gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 1); osc.start(now); osc.stop(now + 1); }
                else if (type === 'tile') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
                else if (type === 'win') { osc.type = 'triangle'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.1); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'lose') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'sniper') { osc.type = 'square'; osc.frequency.setValueAtTime(880, now); osc.frequency.exponentialRampToValueAtTime(110, now + 0.3); gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'glitch') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(600, now + 0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
                else if (type === 'powerup') { osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(880, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
                else if (type === 'roll') { osc.type = 'noise'; osc.frequency.setValueAtTime(1000, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); }
            } catch (e) { console.error(e); }
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // ... (IconMap, DiceIcon, getIcon, Map Constants, PlayerAvatar, BoardCell components are preserved) ...
        const IconMap = {
            Zap: <Zap />,
            ArrowUp: <ArrowUp />,
            ArrowDown: <ArrowDown />,
            ChevronsUp: <ChevronsUp />,
            Footprints: <Footprints />,
            Shuffle: <Shuffle />,
            Bomb: <Bomb />,
            RefreshCcw: <RefreshCcw />,
            ShieldAlert: <ShieldAlert />,
            Skull: <Skull />,
            ArrowRight: <ArrowRight />,
            Gavel: <Gavel />,
            ArrowLeftRight: <ArrowLeftRight />,
            Siren: <Siren />,
            Rewind: <Rewind />,
            Swords: <SwordsIcon />,
            Coins: <Coins />,
            Scope: <Scope />,
            Bug: <Bug />,
            Dices: <Dices />,
            List: <List />,
            Hash: <Hash />,
            Anchor: <Anchor />,
            Droplets: <Droplets />,
            Hand: <Hand />,
            Gauge: <Gauge />,
            TrendingDown: <TrendingDown />
        };
        
        const DiceIcon = ({val}) => {
             if (val === 1) return <Dice1 size={32}/>;
             if (val === 2) return <Dice2 size={32}/>;
             if (val === 3) return <Dice3 size={32}/>;
             if (val === 4) return <Dice4 size={32}/>;
             if (val === 5) return <Dice5 size={32}/>;
             return <Dice6 size={32}/>;
        }

        const getIcon = (icon) => {
            if (typeof icon === 'string') return IconMap[icon] || <Info />;
            return icon;
        };

        const CLASSIC_MAP = {
        max: 60,
        specials: {
            6: { type: 'JUMP', val: 12, name: 'Ponte', icon: <ArrowRight />, desc: "Attraversa il ponte! Vai direttamente alla casella 12." },
            15: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." }, 
            16: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            18: { type: 'CHALLENGE', name: 'Sfida', icon: <SwordsIcon />, desc: "Sfida un giocatore! Best of 3." },
            19: { type: 'WAIT', turns: 2, name: 'Pozzo', icon: <RefreshCcw />, desc: "Sei caduto nel Pozzo! Devi aspettare 2 turni per risalire." }, 
            22: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            25: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti subito dietro al giocatore che ti precede in classifica." },
            26: { type: 'EXTRA_DICE', name: 'Dado Extra', icon: <Dices />, desc: "Potenziamento! Al prossimo turno lancerai DUE dadi!" },
            28: { type: 'SWITCH', name: 'Switch', icon: <ArrowLeftRight />, desc: "Caos! Scambi la posizione con un giocatore a caso." },
            31: { type: 'WAIT', turns: 2, name: 'Pozzo 2', icon: <RefreshCcw />, desc: "Un altro pozzo! Aspetta 2 turni." },
            33: { type: 'FRONT', name: 'In Fronte', icon: <Footprints className="rotate-180" />, desc: "Ti piazzi davanti! Vai alla casella davanti al giocatore che ti segue." },
            39: { type: 'CHALLENGE', name: 'Sfida', icon: <SwordsIcon />, desc: "Sfida un giocatore! Best of 3." },
            42: { type: 'BACK', val: 30, name: 'Labirinto', icon: <ArrowDown />, desc: "Ti sei perso nel Labirinto! Torni indietro alla casella 30." },
            44: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            45: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            48: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            51: { type: 'FRONT', name: 'In Fronte', icon: <Footprints className="rotate-180" />, desc: "Strategia inversa! Ti piazzi davanti all'inseguitore." },
            52: { type: 'WAIT', turns: 2, name: 'Prigione', icon: <ShieldAlert />, desc: "Sei stato arrestato! Rimani in Prigione per 2 turni." },
            58: { type: 'RESTART', name: 'Scheletro', icon: <Skull />, desc: "Lo Scheletro ti ha spaventato! Torni all'inizio (START)." },
            5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            9: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            11: { type: 'BOOST', val: 4, name: '+4', icon: <Zap />, desc: "Turbo! Vola avanti di 4 caselle." },
            14: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            23: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            27: { type: 'BOOST', val: -1, name: '-1', icon: <ArrowDown />, desc: "Vento contrario! Torni indietro di 1 casella." },
            36: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            38: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" },
            40: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Strategia! Ti teletrasporti subito dietro al giocatore che ti precede." },
            46: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Volata finale! +3 caselle." },
            50: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            54: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            56: { type: 'BOOST', val: -3, name: '-3', icon: <ArrowDown />, desc: "No! Sei quasi alla fine ma scivoli indietro di 3!" },
        }
        };

        const REVERSE_MAP = {
            max: 0,
            specials: {
                ...CLASSIC_MAP.specials,
                6: { ...CLASSIC_MAP.specials[6], desc: "Il ponte ti porta alla 12... più vicino al traguardo!" },
                42: { ...CLASSIC_MAP.specials[42], name: "Scorciatoia", icon: <Rewind/>, desc: "Scorciatoia Labirinto! Salti alla 30 (più vicino allo zero)!" },
                58: { ...CLASSIC_MAP.specials[58], desc: "Lo scheletro ti manda allo START (0)! VITTORIA ISTANTANEA?!" },
                5: { ...CLASSIC_MAP.specials[5], name: 'Malus +2', icon: <ArrowUp/>, desc: "Oh no! Ti allontani di 2 caselle dallo zero!" },
                9: { ...CLASSIC_MAP.specials[9], name: 'Malus +3', icon: <Zap/>, desc: "Disastro! Corri indietro verso la 60!" },
                11: { ...CLASSIC_MAP.specials[11], name: 'Malus +4', icon: <Zap/>, desc: "Turbo al contrario! +4 caselle!" },
                14: { ...CLASSIC_MAP.specials[14], name: 'Malus +2', icon: <ArrowUp/>, desc: "Indietro di 2!" },
                23: { ...CLASSIC_MAP.specials[23], name: 'Bonus -2', icon: <ArrowDown/>, desc: "Scivolata fortunata! Ti avvicini allo zero di 2!" },
                27: { ...CLASSIC_MAP.specials[27], name: 'Bonus -1', icon: <ArrowDown/>, desc: "Vento a favore! -1 casella!" },
                36: { ...CLASSIC_MAP.specials[36], name: 'Malus +3', icon: <Zap/>, desc: "Sprint sbagliato! +3 caselle!" },
                50: { ...CLASSIC_MAP.specials[50], name: 'Bonus -2', icon: <ArrowDown/>, desc: "Ottimo! -2 caselle!" },
                56: { ...CLASSIC_MAP.specials[56], name: 'Bonus -3', icon: <ArrowDown/>, desc: "Evvai! Scivoli verso la vittoria!" },
            }
        };

        const ELIM_MAP = {
        max: 34,
        specials: {
            3: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint iniziale! +3 caselle." },
            7: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! +3 caselle." },
            8: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" }, 
            10: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino!" },
            12: { type: 'BACK', val: 5, name: 'Trappola', icon: <Bomb />, desc: "È una trappola! Torni alla casella 5." },
            14: { type: 'SWITCH', name: 'Switch', icon: <ArrowLeftRight />, desc: "Caos! Scambi la posizione con un giocatore a caso." },
            15: { type: 'BOOST', val: 4, name: '+4', icon: <Zap />, desc: "Mega Sprint! Corri avanti di 4 caselle." },
            17: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti dietro al giocatore davanti a te." },
            20: { type: 'BACK', val: 10, name: 'Labirinto', icon: <ArrowDown />, desc: "Labirinto insidioso! Torni alla casella 10." }, 
            22: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Scegli il tuo destino! 3 opzioni casuali." },
            25: { type: 'BACK', val: 18, name: 'Tornado', icon: <ArrowDown />, desc: "Un tornado ti spazza via! Torni alla 18." },
            26: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            32: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Sei quasi alla fine ma scivoli! Indietro di 2." },
        }
        };

        const GEM_MAP = {
            max: 50,
            specials: {
                5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                12: { type: 'BOOST', val: 1, name: '+1', icon: <ArrowUp />, desc: "Avanza di 1" },
                18: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                22: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" },
                30: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                38: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                45: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" }
            }
        };
        
        const BATTLE_ROYALE_MAP = {
            max: 40,
            specials: {
                5: { type: 'BOOST', val: 2, name: '+2', icon: <Zap/>, desc: 'Boost!' },
                8: { type: 'BOOST', val: -3, name: '-3', icon: <ArrowDown/>, desc: 'Scivolata! Indietro di 3.' },
                9: { type: 'TAIL', name: 'In Coda', icon: <Footprints/>, desc: 'Ti metti in scia!' },
                10: { type: 'DECISION', name: 'Decisione', icon: <Gavel/>, desc: 'Scegli il tuo destino!' },
                12: { type: 'BOOST', val: 3, name: '+3', icon: <Zap/>, desc: 'Sprint!' },
                14: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown/>, desc: 'Indietro di 2.' },
                15: { type: 'DECISION', name: 'Bivio', icon: <Gavel/>, desc: 'Scegli!' },
                17: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento!" },
                18: { type: 'SWITCH', name: 'Switch', icon: <ArrowLeftRight/>, desc: 'Scambio!' },
                22: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle/>, desc: 'Portale instabile!' },
                25: { type: 'BACK', val: 15, name: 'Baratro', icon: <Skull/>, desc: 'Disastro! Torna alla 15.' },
                28: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp/>, desc: 'Ultimo sforzo!' },
                29: { type: 'WAIT', turns: 2, name: 'Pozzo', icon: <RefreshCcw />, desc: "Sei caduto nel Pozzo!" },
                30: { type: 'BOOST', val: -10, name: '-10', icon: <ArrowDown/>, desc: 'Disastro totale! Indietro di 10.' },
                34: { type: 'FRONT', name: 'In Fronte', icon: <Footprints className="rotate-180" />, desc: "Ti piazzi davanti!" },
                38: { type: 'BOOST', val: -1, name: '-1', icon: <ArrowDown/>, desc: 'Indietro di 1.' },
                39: { type: 'BOOST', val: -5, name: '-5', icon: <ArrowDown/>, desc: 'Indietro di 5.' }
            }
        };

        const HUNTER_MAP = {
            max: 80,
            specials: {
                ...CLASSIC_MAP.specials,
                58: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Hai schivato lo scheletro! +2" }, // Rimpiazza lo scheletro classico
                62: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint verso la libertà!" },
                65: { type: 'WAIT', turns: 1, name: 'Trappola', icon: <Lock />, desc: "La polizia ti ha rallentato! Fermo 1 turno." },
                68: { type: 'DECISION', name: 'Decisione', icon: <Gavel />, desc: "Ultimo bivio!" },
                72: { type: 'BACK', val: 55, name: 'Allarme', icon: <Siren />, desc: "Allarme rosso! Torni indietro alla 55." },
                75: { type: 'TELEPORT', name: 'Portale', icon: <Shuffle />, desc: "Ultima chance di fuga." },
                76: { type: 'RESTART', name: 'Scheletro', icon: <Skull />, desc: "PRESO! Lo scheletro ti riporta allo START." },
                79: { type: 'BOOST', val: -1, name: '-1', icon: <ArrowDown />, desc: "Così vicino! Indietro di 1." }
            }
        };

        const DECISION_POOL = [
            { id: 'leadership', name: 'Leadership', desc: "Tutti avanzano di 2, tu di 4.", icon: <Users/> },
            { id: 'target_back_4', name: 'Sabotaggio', desc: "Scegli chi arretra di 4 caselle.", icon: <ArrowDown/> },
            { id: 'teleport', name: 'Portale', desc: "Ti teletrasporti da un giocatore a caso.", icon: <Shuffle/> },
            { id: 'curse', name: 'Maledizione', desc: "Scegli chi userà il dado maledetto (-3,-2,-1,0,1,2).", icon: <Ban/> },
            { id: 'reroll', name: 'Seconda Chance', desc: "Rilancia subito il dado.", icon: <RefreshCcw/> },
            { id: 'turbo', name: 'Turbo', desc: "Avanza di 5 caselle.", icon: <Zap/> },
            { id: 'vampire', name: 'Vampirismo', desc: "Rubi 3 caselle a un avversario.", icon: <Droplets/> },
            { id: 'anchor', name: 'Zavorra', desc: "Tutti gli altri arretrano di 2.", icon: <Anchor/> },
            { id: 'gamble', name: 'Scommessa', desc: "50/50: +6 o -3.", icon: <Dices/> },
            { id: 'force_stop', name: 'Sosta Forzata', desc: "Blocca un giocatore per 1 turno.", icon: <Hand/> },
            { id: 'targeted_swap', name: 'Scambio Mirato', desc: "Scambia posizione con chi vuoi.", icon: <ArrowLeftRight/> }
        ];

        const PlayerAvatar = ({ charId, size = "md", border = true }) => {
        const s = size === 'sm' ? 'w-8 h-8' : size === 'lg' ? 'w-16 h-16' : 'w-10 h-10';
        const safeCharId = (charId >= 0 && charId < ROSTER.length) ? charId : 0;
        return (
            <img src={ROSTER[safeCharId].img} className={`${s} rounded-full object-cover ${border ? 'border-2 border-white shadow-sm' : ''}`} alt="Avatar" />
        );
        };

        const BoardCell = ({ num, players, special, isElimination, isPendingTarget, onCellClick, onInfoClick, gems, infected, isTargetSelection, lavaTiles, blackHolePos, bossTargetUid, tileOwnerColor, isValidMoveTarget, isTilesMode, isReverse, isBattleRoyale, coinLocations, sniperTargets, activeGlitch, currentUserId, voidTiles, warningTiles, isTournament }) => {
            let bgClass = "bg-slate-100";
            let borderClass = "border-slate-300";
            let cursorClass = "cursor-pointer"; 
            let highlightClass = "";
            let customStyle = {};

            const hasGem = gems && gems.includes(num);
            const isLava = lavaTiles && lavaTiles.includes(num);
            const isBlackHole = blackHolePos !== undefined && num <= blackHolePos;
            const coin = coinLocations?.find(c => c.pos === num);
            const isSniperTarget = sniperTargets && sniperTargets.includes(num);
            const isVoid = voidTiles && voidTiles.includes(num);
            const isWarning = warningTiles && warningTiles.includes(num);

            // Tile Ownership Logic
            if (tileOwnerColor) {
                customStyle = { backgroundColor: tileOwnerColor, borderColor: 'white' };
                // Lighten the text so numbers are visible on dark colors
                bgClass = "text-white shadow-inner";
            }

            // Normal start/end logic only if NOT in Tiles/Brawl mode
            if (num === 0 && !tileOwnerColor && !isTilesMode && !isVoid) { 
                bgClass = isReverse ? "bg-yellow-200" : "bg-green-200"; 
                borderClass = isReverse ? "border-yellow-400" : "border-green-400"; 
            }
            else if (num === (isBattleRoyale ? 40 : (isElimination ? 34 : (special && !special.max && special.max !== 0 ? 60 : 50))) && !tileOwnerColor && !isTilesMode && !isVoid) { 
                 if (num === 60) {
                     bgClass = isReverse ? "bg-green-200" : "bg-yellow-200"; 
                     borderClass = isReverse ? "border-green-400" : "border-yellow-400";
                 } else {
                    bgClass = "bg-yellow-200"; borderClass = "border-yellow-400"; 
                 }
            }
            else if (special && !tileOwnerColor && !isVoid) {
                // Adjust colors for Reverse Mode (Boost is Bad, Back is Good)
                const isBad = (special.type === 'BOOST' && special.val > 0) || special.type === 'DOUBLE';
                const isGood = (special.type === 'BOOST' && special.val < 0) || special.type === 'BACK';
                
                if (isReverse) {
                     if (isBad) { bgClass = "bg-red-100"; borderClass = "border-red-300"; }
                     else if (isGood) { bgClass = "bg-cyan-100"; borderClass = "border-cyan-300"; }
                } else {
                     if (isBad) { bgClass = "bg-cyan-100"; borderClass = "border-cyan-300"; } // Actually Good in normal
                     else if (isGood) { bgClass = "bg-red-100"; borderClass = "border-red-300"; } // Actually Bad in normal
                }
                
                if (special.type === 'JUMP') { bgClass = "bg-cyan-100"; borderClass = "border-cyan-300"; }
                if (special.type === 'WAIT') { bgClass = "bg-slate-300"; borderClass = "border-slate-500"; }
                if (special.type === 'TAIL' || special.type === 'FRONT' || special.type === 'TELEPORT' || special.type === 'SWITCH') { bgClass = "bg-purple-200"; borderClass = "border-purple-400"; }
                if (special.type === 'DECISION') { bgClass = "bg-amber-100"; borderClass = "border-amber-400"; }
                if (special.type === 'EXTRA_DICE') { bgClass = "bg-blue-200"; borderClass = "border-blue-500"; }
                if (special.type === 'RESTART') { bgClass = "bg-red-200"; borderClass = "border-red-500"; }
                if (special.type === 'CHALLENGE') { bgClass = "bg-amber-500 text-white"; borderClass = "border-amber-700"; }
            }

            if (isLava) { bgClass = "bg-orange-500 animate-pulse ring-2 ring-red-600"; borderClass = "border-red-600"; }
            if (isBlackHole) { bgClass = "black-hole-bg text-white border-black"; borderClass = "border-slate-900"; }
            if (hasGem) { bgClass = "bg-indigo-900"; borderClass = "border-yellow-400"; }
            if (isSniperTarget) { bgClass = "bg-red-500 animate-ping"; borderClass = "border-red-700"; }
            if (isWarning) { bgClass = "bg-red-400 animate-pulse ring-4 ring-red-500"; borderClass = "border-red-600"; }
            if (isVoid) { bgClass = "void-tile pointer-events-none"; borderClass = "border-slate-800"; cursorClass = "cursor-default"; }

            // Coin styling
            if (coin) {
                 if (coin.val === 3) { bgClass = "bg-yellow-100"; borderClass = "border-yellow-400"; }
                 else if (coin.val === 2) { bgClass = "bg-slate-100"; borderClass = "border-slate-300"; }
                 else { bgClass = "bg-orange-50"; borderClass = "border-orange-200"; }
            }

            if (isPendingTarget && !isVoid) { highlightClass = "ring-4 ring-yellow-400 ring-offset-2 animate-pulse z-40 shadow-xl bg-yellow-50 scale-105"; cursorClass = "cursor-pointer hover:bg-yellow-100"; }
            if (isValidMoveTarget && !isVoid) {
                 highlightClass = "ring-4 ring-green-400 ring-offset-2 animate-pulse z-40 shadow-xl bg-green-50 scale-105"; 
                 cursorClass = "cursor-pointer hover:bg-green-100"; 
            }
            if (isTargetSelection) { cursorClass = "cursor-pointer"; highlightClass="hover:ring-2 hover:ring-indigo-500"; }
            const resolvedIcon = special ? getIcon(special.icon) : null;

            return (
                <div 
                onClick={() => {
                    if (isVoid) return;
                    if (isPendingTarget) onCellClick();
                    else if (isValidMoveTarget) onCellClick();
                    else if (isTargetSelection) onCellClick();
                    else if (special) onInfoClick({...special, icon: resolvedIcon});
                }}
                style={customStyle}
                className={`relative w-full aspect-square border-2 rounded-xl flex flex-col p-1 shadow-sm transition-all duration-300 ${bgClass} ${borderClass} ${highlightClass} ${cursorClass}`}
                >
                <div className="flex justify-between items-start opacity-60">
                    <span className={`font-bold text-xs md:text-sm ${hasGem || isLava || isBlackHole || tileOwnerColor || isSniperTarget || isWarning ? 'text-white/90 drop-shadow-md' : (isVoid ? 'text-slate-700' : '')}`}>
                        {(!isVoid) && (num === 0 && !isTilesMode ? (isReverse ? 'FINE' : 'START') : (num === 60 && !isTilesMode && isReverse ? 'START' : num))}
                    </span>
                    {special && !isLava && !isBlackHole && !isSniperTarget && !isVoid && <span className="text-xs">{resolvedIcon}</span>}
                    {isLava && <Flame className="text-yellow-300 fill-orange-600 animate-bounce" size={16}/>}
                    {isBlackHole && <Disc className="text-purple-500 animate-spin" size={12}/>}
                    {isSniperTarget && <Scope className="text-white animate-ping" size={16}/>}
                    {isWarning && <ShieldAlert className="text-white animate-bounce" size={16}/>}
                </div>
                {hasGem && !isVoid && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <Gem className="text-yellow-400 gem-glow animate-bounce" size={24} fill="gold"/>
                    </div>
                )}
                {coin && !isVoid && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-10">
                        <Coins 
                            className={`animate-bounce ${coin.val === 3 ? 'text-yellow-500 coin-glow-3' : (coin.val === 2 ? 'text-slate-400 coin-glow-2' : 'text-orange-700 coin-glow-1')}`} 
                            size={20} 
                            fill={coin.val === 3 ? 'gold' : (coin.val === 2 ? 'silver' : '#cd7f32')}
                        />
                        <span className={`text-[10px] font-black ${coin.val === 3 ? 'text-yellow-600' : 'text-slate-500'}`}>{coin.val}</span>
                    </div>
                )}
                <div className="flex-1 flex flex-wrap content-center justify-center gap-1 z-10">
                    {infected && infected.position === num && !isVoid && (
                        <div className="relative z-30 animate-pulse">
                             <div className="rounded-full border-2 border-green-900 bg-green-500 p-1 shadow-lg">
                                <Biohazard size={20} className="text-green-900"/>
                             </div>
                        </div>
                    )}
                    {players.map(p => {
                        // DARKNESS GLITCH: Hide opponents if enabled
                        if (activeGlitch === 'darkness' && p.uid !== currentUserId) return null;

                        const teamColor = p.teamId !== undefined && TEAM_COLORS[p.teamId] ? TEAM_COLORS[p.teamId].border : 'border-white';
                        return (
                            <div key={p.id} onClick={(e) => {
                                if (isTargetSelection) {
                                    // Let click bubble up if selecting tiles, block if selecting players
                                }
                            }} className={`relative transition-all duration-300 ${p.finished || p.isDead ? 'opacity-50 scale-75' : 'hover:scale-125 hover:z-20'} ${isTargetSelection ? 'cursor-pointer' : ''}`}>
                                <div className={`rounded-full border-2 ${teamColor} p-[1px]`}>
                                    <PlayerAvatar charId={p.characterId} size="sm" border={false} />
                                </div>
                                {p.activeCurse && <div className="absolute -top-2 -right-2 bg-purple-900 text-white rounded-full p-0.5 border border-white z-20"><Ban size={10}/></div>}
                                {p.extraDice && <div className="absolute -top-2 -left-2 bg-blue-500 text-white rounded-full p-0.5 border border-white z-20"><Dices size={10}/></div>}
                                {p.uid === bossTargetUid && <div className="absolute -top-3 -right-3 text-red-600 animate-pulse z-30 drop-shadow-md"><Crosshair size={24}/></div>}
                                {p.skipTurns > 0 && <div className="absolute inset-0 bg-black/50 rounded-full flex items-center justify-center text-white text-[10px] font-bold">{p.skipTurns}</div>}
                                {p.finished && <div className="absolute -top-1 -right-1 bg-green-500 text-white rounded-full p-0.5"><Flag size={8}/></div>}
                                {p.isDead && <div className="absolute inset-0 bg-black/70 rounded-full flex items-center justify-center"><Skull className="text-white" size={14}/></div>}
                            </div>
                        );
                    })}
                </div>
                {isPendingTarget && !isVoid && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <Pointer className="text-yellow-600 animate-bounce w-8 h-8 drop-shadow-md fill-yellow-300" />
                    </div>
                )}
                {special && !isVoid && <div className={`text-[8px] md:text-[10px] text-center leading-tight truncate font-semibold opacity-80 ${hasGem || isLava || isBlackHole || tileOwnerColor || isSniperTarget || isWarning || special.type === 'CHALLENGE' ? 'text-white' : ''}`}>{special.name}</div>}
                </div>
            );
        };

        function App() {
            // ... (useState hooks preserved) ...
            const [user, setUser] = useState(null);
            const [view, setView] = useState('menu');
            const [roomCode, setRoomCode] = useState('');
            const [nickname, setNickname] = useState('');
            const [currentRoom, setCurrentRoom] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [isMoving, setIsMoving] = useState(false); 
            const [lastRoll, setLastRoll] = useState(null);
            const [notif, setNotif] = useState(null); 
            const [selectedCellInfo, setSelectedCellInfo] = useState(null);
            const [useSpecialDie, setUseSpecialDie] = useState(false);
            const [directionChoice, setDirectionChoice] = useState(null); 
            const [decisionMode, setDecisionMode] = useState(false);
            const [decisionOptions, setDecisionOptions] = useState([]);
            const [targetSelectionMode, setTargetSelectionMode] = useState(null);
            const [bossTargetSelection, setBossTargetSelection] = useState(false);
            const [errorMsg, setErrorMsg] = useState(null);
            const [relayConfig, setRelayConfig] = useState({ teams: 2, size: 2 });
            const [turnLimit, setTurnLimit] = useState(10); 
            const [selectedPaintColor, setSelectedPaintColor] = useState(PAINT_COLORS[0]);
            const [sniperSelection, setSniperSelection] = useState([]);
            const [botSpeed, setBotSpeed] = useState(1);
            const [brConfigInput, setBrConfigInput] = useState("");
            const [tournamentRounds, setTournamentRounds] = useState(3);
            const lastBotTurnRef = useRef({ turn: -1, timestamp: 0 });

            const handleError = (error) => {
                console.error("Errore rilevato:", error);
                setErrorMsg(error.message || "Si è verificato un errore.");
                setTimeout(() => setErrorMsg(null), 8000); 
            };

            const toggleBotSpeed = () => {
                if (botSpeed === 1) setBotSpeed(2); // 2X Speed
                else if (botSpeed === 2) setBotSpeed(10); // MAX Speed (Instant)
                else setBotSpeed(1); // Reset
            };
            
            // ... (generateEliminationSpecials, generateCoins, useEffects, createRoom, joinRoom, setGuard, startGame, fillLobbyBots, addBot, selectChar, updatePaintColor, switchTeam, toggleBotModeLobby, toggleGenericBotMode, isPawnLocked, checkTeamWin, getGridWidth, getCoords, getManhattanDistance, executeTileMove - NO CHANGES) ...
            
            const generateEliminationSpecials = () => {
                const max = 34;
                const pool = [
                    { type: 'BOOST', val: 3, name: '+3', icon: 'Zap', desc: "Sprint! +3 caselle." },
                    { type: 'BOOST', val: 3, name: '+3', icon: 'Zap', desc: "Sprint! +3 caselle." },
                    { type: 'BOOST', val: 4, name: '+4', icon: 'Zap', desc: "Mega Sprint! +4 caselle." },
                    { type: 'DOUBLE', name: 'Raddoppia', icon: 'ChevronsUp', desc: "X2 Movimento!" },
                    { type: 'TAIL', name: 'In Coda', icon: 'Footprints', desc: "Ti metti in scia all'avversario!" },
                    { type: 'TAIL', name: 'In Coda', icon: 'Footprints', desc: "Ti metti in scia all'avversario!" }, 
                    { type: 'TELEPORT', name: 'Teletrasporto', icon: 'Shuffle', desc: "Scambio posizioni!" },
                    { type: 'SWITCH', name: 'Switch', icon: 'ArrowLeftRight', desc: "Scambi la posizione con un giocatore a caso." },
                    { type: 'DECISION', name: 'Decisione', icon: 'Gavel', desc: "Scegli il tuo destino!" },
                    { type: 'DECISION', name: 'Decisione', icon: 'Gavel', desc: "Scegli il tuo destino!" },
                    { type: 'BOOST', val: -2, name: '-2', icon: 'ArrowDown', desc: "Scivolata! Indietro di 2." },
                    { type: 'BACK_REL', val: 5, name: 'Trappola', icon: 'Bomb', desc: "Trappola! Indietro di 5." }, 
                    { type: 'BACK_REL', val: 10, name: 'Labirinto', icon: 'ArrowDown', desc: "Labirinto! Indietro di 10." }
                ];
                const specials = {};
                const usedPos = new Set([0, max]);
                pool.forEach(item => {
                    let pos;
                    let attempts = 0;
                    do { pos = Math.floor(Math.random() * (max - 2)) + 1; attempts++; } while (usedPos.has(pos) && attempts < 100);
                    if (!usedPos.has(pos)) {
                        usedPos.add(pos);
                        let finalItem = { ...item };
                        if (item.type === 'BACK_REL') { finalItem.type = 'BACK'; finalItem.val = Math.max(0, pos - item.val); }
                        specials[pos] = finalItem;
                    }
                });
                return specials;
            };

            const generateCoins = (currentCoins, count) => {
                const newCoins = [...currentCoins];
                const occupied = new Set(newCoins.map(c => c.pos));
                for(let i=0; i<count; i++) {
                     let pos;
                     let attempts = 0;
                     do { pos = Math.floor(Math.random() * 121); attempts++; } while ((occupied.has(pos) || pos === 0) && attempts < 100);
                     const rand = Math.random();
                     const val = rand > 0.9 ? 3 : (rand > 0.6 ? 2 : 1); 
                     newCoins.push({ pos, val });
                     occupied.add(pos);
                }
                return newCoins;
            }

            useEffect(() => {
                const initAuth = async () => { try { await signInAnonymously(auth); } catch (e) { handleError(e); } };
                initAuth();
                return onAuthStateChanged(auth, u => setUser(u));
            }, []);

            useEffect(() => {
                if (!roomCode || !user) return;
                const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), (snap) => {
                    if (snap.exists()) {
                        const data = snap.data();
                        setCurrentRoom(data);
                        if (data.status === 'playing' && view !== 'game') setView('game');
                        if (data.status === 'waiting' && view !== 'lobby') setView('lobby');
                        
                        // Check if Boss needs to select target
                        if (data.status === 'playing' && data.gameMode === 'raid_boss' && data.players[data.currentTurn].uid === user.uid && data.bossTargetUid === null && data.players[data.currentTurn].uid === data.hostId) {
                            setBossTargetSelection(true);
                        } else {
                            setBossTargetSelection(false);
                        }
                    } else { setView('menu'); }
                }, (err) => { handleError(err); });
                return () => unsub();
            }, [roomCode, view, user]);

            useEffect(() => {
                if (currentRoom?.lastAction) {
                setNotif(currentRoom.lastAction);
                const t = setTimeout(() => setNotif(null), 3000);
                return () => clearTimeout(t);
                }
            }, [currentRoom?.lastAction]);
            
            // ... (createRoom, joinRoom, setGuard, startGame, fillLobbyBots, addBot, selectChar, updatePaintColor, switchTeam, toggleBotModeLobby, toggleGenericBotMode, isPawnLocked, checkTeamWin, getGridWidth, getCoords, getManhattanDistance, executeTileMove functions are preserved) ...
            
             const createRoom = async (mode) => {
                if (!nickname || !user) return;
                try {
                    const code = Math.random().toString(36).substring(2, 7).toUpperCase();
                    const charId = Math.floor(Math.random() * ROSTER.length);
                    let extraData = {};
                    if (mode === 'infection') extraData.infectedNPC = { position: 0, lastMovedRound: 0 };
                    if (mode === 'gem_hunt') {
                        const gems = [];
                        while(gems.length < 3) { const r = Math.floor(Math.random() * 40) + 5; if(!gems.includes(r)) gems.push(r); }
                        extraData.gemLocations = gems;
                    }
                    if (mode === 'coin_collector') {
                        extraData.coinLocations = generateCoins([], 5);
                        extraData.maxScore = 30;
                    }
                    if (mode === 'lava') extraData.lavaTiles = [];
                    if (mode === 'elimination') extraData.customSpecials = generateEliminationSpecials();
                    if (mode === 'black_hole') extraData.blackHolePos = 0;
                    if (mode === 'raid_boss') {
                        extraData.bossHp = 50;
                        extraData.bossTargetUid = null;
                    }
                    if (mode === 'relay') {
                        extraData.teamBotModes = { 0: 'auto', 1: 'auto', 2: 'auto', 3: 'auto' };
                    }
                    if (mode === 'tiles') {
                        extraData.tileOwners = {}; 
                        extraData.maxRounds = 10;
                    }
                    if (mode === 'hunter') {
                        extraData.guardUid = user.uid; // Host is Guard by default
                    }
                    if (mode === 'battle_royale') {
                        extraData.qualifyLimit = 16;
                        extraData.battleRoundIndex = 0;
                        extraData.battleRoundConfig = [16, 8, 4, 2, 1]; // Default configuration
                    }
                    if (mode === 'sniper') {
                        extraData.sniperTargets = [];
                        extraData.sniperUid = user.uid;
                    }
                    if (mode === 'glitch') {
                        extraData.activeGlitch = null;
                        extraData.lavaTiles = []; // Initialize for random_lava
                        extraData.blackHolePos = 0; // Initialize for black_hole
                    }
                    if (mode === 'brawl') {
                        extraData.mapSize = 8; // 8x8
                        extraData.voidTiles = [];
                        extraData.warningTiles = [];
                        extraData.lavaTiles = [];
                    }
                    if (mode === 'tournament') {
                        extraData.maxPlayers = 8;
                        extraData.tournamentTotalRounds = tournamentRounds;
                        extraData.tournamentRoundsConfig = [2, 3, 4];
                    }

                    const playerObj = { 
                        uid: user.uid, name: nickname, characterId: charId, position: 0, 
                        skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: false, 
                        pendingTarget: null, activeCurse: false, pawnIdx: 0,
                        paintColor: mode === 'tiles' ? selectedPaintColor : null,
                        remainingMoves: 0,
                        lives: 1, // Default lives for everyone
                        extraDice: false,
                        score: 0, // Tournament Score
                        laps: 0 // Pressure mode laps
                    };

                    if (mode === 'gem_hunt') playerObj.position = Math.random() > 0.5 ? 0 : 50;
                    if (mode === 'relay') playerObj.teamId = 0;
                    if (mode === 'gem_hunt') playerObj.collectedGems = [];
                    if (mode === 'coin_collector') playerObj.score = 0;
                    if (mode === 'lava') playerObj.lives = 2;
                    if (mode === 'raid_boss') playerObj.lives = 999; 
                    if (mode === 'tiles') playerObj.position = 0; 
                    if (mode === 'reverse') playerObj.position = 60;
                    if (mode === 'coin_collector') playerObj.position = 0;
                    if (mode === 'sniper') {
                        playerObj.lives = 999; // Sniper is immortal
                        playerObj.position = 60; // Sniper at end
                    }
                    if (mode === 'brawl') {
                        playerObj.lives = 3;
                    }

                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', code), {
                        code, hostId: user.uid, gameMode: mode, teamConfig: mode === 'relay' ? relayConfig : null, status: 'waiting', currentTurn: 0, round: 1, ...extraData, duelState: null,
                        players: [playerObj],
                        lastAction: "Stanza Creata"
                    });
                    setRoomCode(code);
                    setView('lobby');
                } catch (e) { handleError(e); }
            };

            const joinRoom = async (codeOverride) => {
                 const codeToJoin = codeOverride || roomCode;
                if (!nickname || !user || !codeToJoin) return;
                try {
                    const cleanCode = codeToJoin.toUpperCase().trim();
                    const ref = doc(db, 'artifacts', appId, 'public', 'data', 'matches', cleanCode);
                    const snap = await getDoc(ref);
                    if (!snap.exists()) { setErrorMsg(`Stanza ${cleanCode} non trovata!`); return; }
                    const data = snap.data();
                    if (data.status !== 'waiting') { setErrorMsg("La partita è già iniziata!"); return; }
                    
                    if (data.gameMode === 'tournament' && data.players.length >= 8) {
                        setErrorMsg("Torneo Pieno (Max 8)!"); return;
                    }

                    setRoomCode(cleanCode);
                    if (data.players.some(p => p.uid === user.uid)) { setView('lobby'); return; }
                    const available = ROSTER.map(c=>c.id).filter(id => !data.players.some(p=>p.characterId === id));
                    const charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                    let bestTeam = 0;
                    if (data.gameMode === 'relay') {
                        const counts = Array(data.teamConfig.teams).fill(0);
                        data.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }
                    let startPos = 0;
                    if (data.gameMode === 'gem_hunt') startPos = Math.random() > 0.5 ? 0 : 50;
                    if (data.gameMode === 'reverse') startPos = 60;
                    if (data.gameMode === 'hunter') startPos = 20;

                    const playerObj = { 
                        uid: user.uid, name: nickname, characterId: charId, position: startPos, 
                        skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: false, 
                        pendingTarget: null, activeCurse: false, pawnIdx: 0,
                        paintColor: data.gameMode === 'tiles' ? selectedPaintColor : null,
                        remainingMoves: 0,
                        lives: 1, // Default lives
                        extraDice: false,
                        score: 0,
                        laps: 0
                    };
                    if (data.gameMode === 'relay') playerObj.teamId = bestTeam;
                    if (data.gameMode === 'gem_hunt') playerObj.collectedGems = [];
                    if (data.gameMode === 'coin_collector') playerObj.score = 0;
                    if (data.gameMode === 'lava') playerObj.lives = 2;
                    if (data.gameMode === 'raid_boss') playerObj.lives = 3; 
                    if (data.gameMode === 'sniper') playerObj.lives = 3;
                    if (data.gameMode === 'brawl') playerObj.lives = 3;

                    await updateDoc(ref, { players: arrayUnion(playerObj) });
                    setView('lobby');
                } catch (e) { handleError(e); }
            };

            const setGuard = async (uid) => {
                 if (!currentRoom || !user || currentRoom.hostId !== user.uid) return;
                 try { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { guardUid: uid }); } catch(e) { handleError(e); }
            }

            const startGame = async () => {
                 try {
                    let gamePlayers = [...currentRoom.players];
                    let updates = { status: 'playing', lastAction: "Partita iniziata!", currentTurn: 0 };

                    if (currentRoom.gameMode === 'relay') {
                         const expandedPlayers = [];
                        const teamSize = currentRoom.teamConfig.size;
                        const numTeams = currentRoom.teamConfig.teams;
                        const teamUsers = Array.from({ length: numTeams }, () => []);
                        gamePlayers.forEach(p => { if (p.teamId < numTeams) teamUsers[p.teamId].push(p); });
                        for (let t = 0; t < numTeams; t++) {
                            const users = teamUsers[t];
                            if (users.length === 0) continue; 
                            for (let slot = 0; slot < teamSize; slot++) {
                                const userIndex = slot % users.length;
                                const baseUser = users[userIndex];
                                let charId = baseUser.characterId;
                                if (slot >= users.length) {
                                    const usedChars = new Set([...gamePlayers.map(p => p.characterId), ...expandedPlayers.map(p => p.characterId)]);
                                    const available = ROSTER.map(c => c.id).filter(id => !usedChars.has(id));
                                    charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                                }
                                expandedPlayers.push({ ...baseUser, id: `${baseUser.uid}_slot${slot}`, pawnIdx: slot, characterId: charId, position: 0, finished: false, skipTurns: 0, pendingTarget: null, activeCurse: false, lives: 1 });
                            }
                        }
                        gamePlayers = [];
                        for(let slot=0; slot<teamSize; slot++) { for(let t=0; t<numTeams; t++) { const pawn = expandedPlayers.find(p => p.teamId === t && p.pawnIdx === slot); if(pawn) gamePlayers.push(pawn); } }
                    } else if (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector') {
                         const startPositions = [0, 120, 10, 110, 5, 115, 55, 65]; 
                         gamePlayers = gamePlayers.map((p, i) => ({
                             ...p, id: p.uid, position: startPositions[i % startPositions.length] || 0
                         }));
                         if (currentRoom.gameMode === 'tiles') updates.maxRounds = turnLimit; 
                    } else if (currentRoom.gameMode === 'reverse') {
                        gamePlayers = gamePlayers.map(p => ({...p, id: p.uid, position: 60})); 
                    } else if (currentRoom.gameMode === 'hunter') {
                         gamePlayers = gamePlayers.map(p => ({ ...p, id: p.uid, position: p.uid === currentRoom.guardUid ? 0 : 20 }));
                    } else if (currentRoom.gameMode === 'battle_royale') {
                        const config = currentRoom.battleRoundConfig || [16, 8, 4, 2, 1];
                        updates.qualifyLimit = config.length > 0 ? config[0] : 1;
                        gamePlayers = gamePlayers.map(p => ({...p, id: p.uid}));
                    } else if (currentRoom.gameMode === 'sniper') {
                        gamePlayers = gamePlayers.map(p => ({ ...p, id: p.uid, position: p.uid === currentRoom.sniperUid ? 60 : 0 }));
                    } else if (currentRoom.gameMode === 'brawl') {
                        const positions = [];
                        while(positions.length < gamePlayers.length) {
                             const r = Math.floor(Math.random() * 64);
                             if (!positions.includes(r)) positions.push(r);
                        }
                        gamePlayers = gamePlayers.map((p, i) => ({ ...p, id: p.uid, position: positions[i] }));
                    } else if (currentRoom.gameMode === 'tournament') {
                        updates.tournamentTotalRounds = tournamentRounds;
                        gamePlayers = gamePlayers.map(p => ({...p, id: p.uid, score: 0}));
                    } else { 
                        gamePlayers = gamePlayers.map(p => ({...p, id: p.uid})); 
                    }
                    
                    updates.players = gamePlayers;
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                } catch (e) { handleError(e); }
            };

            const fillLobbyBots = async () => {
                 if (!currentRoom || !user) return;
                 const needed = (currentRoom.gameMode === 'tournament' ? 8 : 32) - currentRoom.players.length;
                 if (needed <= 0) return;
                 const bots = [];
                 const usedChars = new Set(currentRoom.players.map(p => p.characterId));
                 for(let i=0; i<needed; i++) {
                     const availableChars = ROSTER.map(c => c.id).filter(id => !usedChars.has(id));
                     const charId = availableChars.length > 0 ? availableChars[Math.floor(Math.random() * availableChars.length)] : Math.floor(Math.random() * ROSTER.length);
                     usedChars.add(charId);
                     const botId = `bot_auto_${Date.now()}_${i}`;
                     const charName = ROSTER[charId].name; 
                     bots.push({
                        uid: botId, id: botId, name: `Bot ${charName}`, characterId: charId, position: 0, skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: true, pendingTarget: null, activeCurse: false, pawnIdx: 0, paintColor: null, remainingMoves: 0, lives: 1, extraDice: false, score: 0, laps: 0
                    });
                 }
                 try { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: [...currentRoom.players, ...bots] }); } catch(e) { handleError(e); }
            };

            const addBot = async () => {
                 if (!currentRoom || !user) return;
                 if (currentRoom.gameMode === 'tournament' && currentRoom.players.length >= 8) { setErrorMsg("Torneo Pieno!"); return; }

                try {
                    const availableChars = ROSTER.map(c => c.id).filter(id => !currentRoom.players.some(p => p.characterId === id));
                    const charId = availableChars.length > 0 ? availableChars[Math.floor(Math.random() * availableChars.length)] : 0;
                    const botId = `bot_${Date.now()}`;
                    let startPos = 0;
                    if (currentRoom.gameMode === 'gem_hunt') startPos = (Math.random() > 0.5 ? 0 : 50);
                    if (currentRoom.gameMode === 'reverse') startPos = 60;
                    if (currentRoom.gameMode === 'hunter') startPos = 20;

                    let bestTeam = 0;
                    if (currentRoom.gameMode === 'relay') {
                        const counts = Array(currentRoom.teamConfig.teams).fill(0);
                        currentRoom.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }
                    const charName = ROSTER[charId].name; 
                    const botPlayer = {
                        uid: botId, id: botId, name: `Bot ${charName}`, characterId: charId, position: startPos, skipTurns: 0, finished: false, isDead: false, rank: 0, isBot: true, pendingTarget: null, activeCurse: false, pawnIdx: 0, paintColor: currentRoom.gameMode === 'tiles' ? PAINT_COLORS[Math.floor(Math.random() * PAINT_COLORS.length)] : null, remainingMoves: 0,
                        lives: 1, // Default lives
                        extraDice: false,
                        score: 0,
                        laps: 0,
                        ...(currentRoom.gameMode === 'relay' ? { teamId: bestTeam } : {}),
                        ...(currentRoom.gameMode === 'gem_hunt' ? { collectedGems: [] } : {}),
                        ...(currentRoom.gameMode === 'coin_collector' ? { score: 0 } : {}),
                        ...(currentRoom.gameMode === 'lava' ? { lives: 2 } : {}),
                        ...(currentRoom.gameMode === 'raid_boss' ? { lives: 3 } : {}),
                        ...(currentRoom.gameMode === 'sniper' ? { lives: 3 } : {}),
                        ...(currentRoom.gameMode === 'brawl' ? { lives: 3 } : {})
                    };
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: arrayUnion(botPlayer) });
                } catch (e) { handleError(e); }
            };

            const selectChar = async (charId) => {
                 if (!currentRoom || !user) return;
                try {
                    const playerIndex = currentRoom.players.findIndex(p => p.uid === user.uid);
                    if (playerIndex === -1) return;
                    const updatedPlayers = [...currentRoom.players];
                    if (updatedPlayers.some(p => p.characterId === charId && p.uid !== user.uid)) return;
                    updatedPlayers[playerIndex] = { ...updatedPlayers[playerIndex], characterId: charId };
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers });
                } catch (e) { handleError(e); }
            };

            const updatePaintColor = async (color) => {
                 setSelectedPaintColor(color);
                 if (!currentRoom || !user) return;
                 const playerIdx = currentRoom.players.findIndex(p => p.uid === user.uid);
                 if (playerIdx === -1) return;
                 let updated = [...currentRoom.players];
                 updated[playerIdx] = { ...updated[playerIdx], paintColor: color };
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
            };

            const switchTeam = async (newTeamId) => {
                 if (!currentRoom || !user) return;
                const playerIdx = currentRoom.players.findIndex(p => p.uid === user.uid);
                if (playerIdx === -1) return;
                let updated = [...currentRoom.players];
                updated[playerIdx] = { ...updated[playerIdx], teamId: newTeamId };
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
            };

            const toggleBotModeLobby = async (teamId) => {
                 if (!currentRoom) return;
                const currentMode = currentRoom.teamBotModes?.[teamId] || 'auto';
                const newMode = currentMode === 'auto' ? 'manual' : 'auto';
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { [`teamBotModes.${teamId}`]: newMode });
            }

            const toggleGenericBotMode = async (uid) => {
                 if (!currentRoom) return;
                 const currentMode = currentRoom.teamBotModes?.[uid] || 'auto';
                 const newMode = currentMode === 'auto' ? 'manual' : 'auto';
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { [`teamBotModes.${uid}`]: newMode });
            }

            const isPawnLocked = (pawn, allPlayers) => {
                if (currentRoom.gameMode !== 'relay') return false;
                if (pawn.pawnIdx === 0) return false; 
                const teammate = allPlayers.find(p => p.teamId === pawn.teamId && p.pawnIdx === pawn.pawnIdx - 1);
                return teammate && !teammate.finished;
            };

            const checkTeamWin = (players, teamId) => {
                const teamPawns = players.filter(p => p.teamId === teamId);
                return teamPawns.every(p => p.finished);
            };

            const getGridWidth = (mode) => mode === 'brawl' ? 8 : 11;

            const getCoords = (idx, width) => ({ x: idx % width, y: Math.floor(idx / width) });

            const getManhattanDistance = (idx1, idx2, width) => {
                const x1 = idx1 % width;
                const y1 = Math.floor(idx1 / width);
                const x2 = idx2 % width;
                const y2 = Math.floor(idx2 / width);
                return Math.abs(x1 - x2) + Math.abs(y1 - y2);
            };

            const executeTileMove = async (playerId, targetPos) => {
                 if (isMoving) return;
                 setIsMoving(true);
                 playSound('tile');
                 try {
                     const currentPlayerIdx = currentRoom.currentTurn;
                     const player = currentRoom.players[currentPlayerIdx];
                     let tempPlayers = [...currentRoom.players];
                     let newTileOwners = { ...currentRoom.tileOwners };
                     
                     if (currentRoom.gameMode === 'brawl') {
                         const targetOccupant = tempPlayers.find(p => p.position === targetPos && !p.isDead && p.uid !== playerId);
                         if (targetOccupant) {
                             const occupantIdx = tempPlayers.findIndex(p => p.uid === targetOccupant.uid);
                             const myCoords = getCoords(player.position, 8);
                             const targetCoords = getCoords(targetPos, 8);
                             const dx = targetCoords.x - myCoords.x;
                             const dy = targetCoords.y - myCoords.y;
                             let pushX = targetCoords.x + (dx * 2);
                             let pushY = targetCoords.y + (dy * 2);
                             let pushIdx = -1;
                             if (pushX >= 0 && pushX < 8 && pushY >= 0 && pushY < 8) { pushIdx = pushY * 8 + pushX; } else { pushIdx = -999; }
                             if (pushIdx === -999 || (currentRoom.voidTiles && currentRoom.voidTiles.includes(pushIdx))) { tempPlayers[occupantIdx].lives -= 1; tempPlayers[occupantIdx].isDead = true; playSound('punch'); } 
                             else { 
                                 tempPlayers[occupantIdx].position = pushIdx; playSound('punch'); 
                                 if (currentRoom.lavaTiles && currentRoom.lavaTiles.includes(pushIdx)) { tempPlayers[occupantIdx].lives -= 1; if (tempPlayers[occupantIdx].lives <= 0) tempPlayers[occupantIdx].isDead = true; playSound('fire'); }
                             }
                         }
                     }

                     tempPlayers[currentPlayerIdx].position = targetPos;
                     
                     // FIX: Lava Check for Mover
                     if (currentRoom.lavaTiles && currentRoom.lavaTiles.includes(targetPos)) {
                         if (tempPlayers[currentPlayerIdx].lives !== undefined) {
                             tempPlayers[currentPlayerIdx].lives -= 1;
                             playSound('fire');
                             if (tempPlayers[currentPlayerIdx].lives <= 0) {
                                 tempPlayers[currentPlayerIdx].isDead = true;
                                 playSound('skull');
                             }
                         }
                     }

                     tempPlayers[currentPlayerIdx].remainingMoves = (tempPlayers[currentPlayerIdx].remainingMoves || 1) - 1;
                     
                     let updates = { players: tempPlayers };

                     if (currentRoom.gameMode === 'coin_collector') {
                        const coinIndex = currentRoom.coinLocations.findIndex(c => c.pos === targetPos);
                        if (coinIndex !== -1) {
                            const coin = currentRoom.coinLocations[coinIndex];
                            tempPlayers[currentPlayerIdx].score = (tempPlayers[currentPlayerIdx].score || 0) + coin.val;
                            let newCoins = [...currentRoom.coinLocations];
                            newCoins.splice(coinIndex, 1);
                            newCoins = generateCoins(newCoins, 1);
                            updates.coinLocations = newCoins;
                            updates.lastAction = `${player.name} prende moneta da ${coin.val}!`;
                            playSound('gem');
                            if (tempPlayers[currentPlayerIdx].score >= currentRoom.maxScore) { updates.status = 'finished'; updates.winner = `${player.name} VINCE CON ${tempPlayers[currentPlayerIdx].score} PUNTI!`; tempPlayers[currentPlayerIdx].finished = true; }
                        }
                     } else if (currentRoom.gameMode === 'tiles') {
                         newTileOwners[targetPos] = player.paintColor;
                         updates.tileOwners = newTileOwners;
                         updates.lastAction = `${player.name} colora!`;
                     }
                     
                     if (tempPlayers[currentPlayerIdx].remainingMoves <= 0) {
                         const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                         if (nextTurn <= currentPlayerIdx) {
                              const newRound = (currentRoom.round || 1) + 1;
                              if (currentRoom.gameMode === 'brawl') {
                                   updates.round = newRound;
                                   if (newRound % 4 === 3) {
                                       const currentMapSize = currentRoom.mapSize || 8;
                                       const nextMapSize = currentMapSize - 1;
                                       const newWarnings = [];
                                       for(let i=0; i<64; i++) { const {x, y} = getCoords(i, 8); if ((x >= nextMapSize || y >= nextMapSize) && (!currentRoom.voidTiles || !currentRoom.voidTiles.includes(i))) { newWarnings.push(i); } }
                                       updates.warningTiles = newWarnings; updates.lastAction = "ATTENZIONE! LA MAPPA STA PER RESTRINGERSI!"; playSound('siren');
                                   }
                                   if (newRound % 4 === 0) {
                                       const currentMapSize = currentRoom.mapSize || 8;
                                       const nextMapSize = currentMapSize - 1;
                                       const newVoids = [...(currentRoom.voidTiles || [])];
                                       const warnings = currentRoom.warningTiles || [];
                                       warnings.forEach(t => { if(!newVoids.includes(t)) newVoids.push(t); });
                                       updates.voidTiles = newVoids; updates.warningTiles = []; updates.mapSize = nextMapSize; updates.lastAction = "LA MAPPA SI È RISTRETTA!"; playSound('boss_hit');
                                       tempPlayers = tempPlayers.map(p => { if (newVoids.includes(p.position) && !p.isDead) { return { ...p, isDead: true, lives: 0 }; } return p; }); updates.players = tempPlayers;
                                   }
                                   if (newRound % 5 === 0) {
                                       let newLava = []; const voids = currentRoom.voidTiles || []; const currentLava = currentRoom.lavaTiles || []; let attempts = 0;
                                       while(newLava.length < 3 && attempts < 100) { const r = Math.floor(Math.random() * 64); if (!voids.includes(r) && !currentLava.includes(r) && !newLava.includes(r)) { newLava.push(r); } attempts++; }
                                       updates.lavaTiles = [...currentLava, ...newLava]; updates.lastAction = "LAVA EMERSA!"; playSound('fire');
                                   }
                                   const living = tempPlayers.filter(p => !p.isDead);
                                   if (living.length <= 1 && tempPlayers.length > 1) { updates.status = 'finished'; updates.winner = living.length === 1 ? `${living[0].name} È L'ULTIMO SOPRAVVISSUTO!` : "TUTTI MORTI!"; playSound('win'); }
                              }
                              else if (currentRoom.gameMode === 'tiles' && newRound > currentRoom.maxRounds) { updates.status = 'finished'; updates.winner = "GARA TERMINATA! CALCOLO PUNTEGGI..."; } 
                              else { updates.round = newRound; if (currentRoom.gameMode === 'tiles') updates.lastAction = `ROUND ${newRound} DI ${currentRoom.maxRounds}!`; }
                         }
                         updates.currentTurn = nextTurn;
                     }
                     await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                 } catch(e) { handleError(e); } finally {
                     setIsMoving(false);
                 }
            };

            const executeMove = async (playerId, targetPos) => {
                if (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl') return;
                if (isMoving) return;
                setIsMoving(true);
                playSound('click');
                setDirectionChoice(null);
                
                try {
                    // CRITICAL FIX: Refresh Data inside function to avoid stale closures
                    const snap = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode));
                    if (!snap.exists()) return;
                    const freshRoom = snap.data();

                    const currentPlayerIdx = freshRoom.currentTurn;
                    const player = freshRoom.players[currentPlayerIdx];
                    
                    // Double check if we are moving the correct player
                    if (player.uid !== playerId) {
                         setIsMoving(false);
                         return;
                    }
                    if (player.isDead) {
                        setIsMoving(false);
                        return;
                    }
                    
                    const currentPos = player.position;
                    // Determine Map Config
                    let config = CLASSIC_MAP;
                    if (freshRoom.gameMode === 'elimination') config = ELIM_MAP;
                    if (freshRoom.gameMode === 'gem_hunt') config = GEM_MAP;
                    if (freshRoom.gameMode === 'reverse') config = REVERSE_MAP;
                    if (freshRoom.gameMode === 'battle_royale') config = BATTLE_ROYALE_MAP;
                    if (freshRoom.gameMode === 'hunter') config = HUNTER_MAP;
                    
                    let effectiveSpecials = config.specials;
                    if (freshRoom.gameMode === 'elimination' && freshRoom.customSpecials) effectiveSpecials = freshRoom.customSpecials;
                    
                    const isBoss = freshRoom.gameMode === 'raid_boss' && player.uid === freshRoom.hostId;
                    const isGuard = freshRoom.gameMode === 'hunter' && player.uid === freshRoom.guardUid;
                    const isSniper = freshRoom.gameMode === 'sniper' && player.uid === freshRoom.sniperUid;
                    const isReverse = freshRoom.gameMode === 'reverse';
                    const isPressure = freshRoom.gameMode === 'pressure';

                    const steps = [];
                    // Handle wrap-around for Pressure mode
                    let wrapped = false;
                    let wrapStepIndex = -1;

                    if (isPressure && targetPos < currentPos && targetPos >= 0 && !player.activeCurse && lastRoll > 0) {
                         // Wrapped from 60 to 1
                         wrapped = true;
                         // Walk to 60
                         for (let i = currentPos + 1; i <= 60; i++) steps.push(i);
                         // Walk from 1 to target
                         wrapStepIndex = steps.length;
                         for (let i = 1; i <= targetPos; i++) steps.push(i);
                    } else {
                         const direction = targetPos >= currentPos ? 1 : -1;
                         const dist = Math.abs(targetPos - currentPos); 
                         for (let i = 1; i <= dist; i++) steps.push(currentPos + (i * direction));
                    }
                    
                    let tempPlayers = [...freshRoom.players];
                    let gemsCollectedThisTurn = [...(player.collectedGems || [])];
                    let tempGemLocations = [...(freshRoom.gemLocations || [])];
                    let tempBossHp = freshRoom.bossHp;
                    let collisionLog = [];

                    for (let sIdx = 0; sIdx < steps.length; sIdx++) {
                        const stepPos = steps[sIdx];
                        let currentLaps = tempPlayers[currentPlayerIdx].laps || 0;
                        if (wrapped && sIdx === wrapStepIndex) currentLaps += 1;
                        
                        tempPlayers[currentPlayerIdx] = { ...tempPlayers[currentPlayerIdx], position: stepPos, laps: currentLaps };
                        
                        if (freshRoom.gameMode === 'hunter') {
                            const guards = tempPlayers.filter(p => p.uid === freshRoom.guardUid && !p.isDead);
                            const thieves = tempPlayers.filter(p => p.uid !== freshRoom.guardUid && !p.isDead && p.position === stepPos);
                            if (isGuard) { 
                                thieves.forEach(t => { 
                                    const tIdx = tempPlayers.findIndex(p => p.uid === t.uid); 
                                    if (tIdx !== -1) { 
                                        tempPlayers[tIdx] = { ...tempPlayers[tIdx], isDead: true, finished: true };
                                        collisionLog.push(`${t.name} ARRESTATO!`); 
                                        playSound('siren'); 
                                    } 
                                }); 
                            } 
                            else { 
                                const guardAtPos = guards.find(g => g.position === stepPos); 
                                if (guardAtPos) { 
                                    tempPlayers[currentPlayerIdx] = { ...tempPlayers[currentPlayerIdx], isDead: true, finished: true };
                                    collisionLog.push(`${player.name} CORRE CONTRO LA GUARDIA! ARRESTATO!`); 
                                    playSound('siren'); 
                                } 
                            }
                        }
                        if (freshRoom.gameMode === 'raid_boss') {
                            const boss = tempPlayers.find(p => p.uid === freshRoom.hostId);
                            const raiders = tempPlayers.filter(p => p.uid !== freshRoom.hostId && !p.isDead && p.position === stepPos);
                            if (isBoss) { raiders.forEach(r => { const rIdx = tempPlayers.findIndex(p => p.uid === r.uid); tempPlayers[rIdx].lives -= 1; playSound('punch'); if (tempPlayers[rIdx].lives <= 0) tempPlayers[rIdx].isDead = true; }); } 
                            else { if (boss && boss.position === stepPos) { if (player.uid === freshRoom.bossTargetUid) { tempPlayers[currentPlayerIdx].lives -= 1; playSound('punch'); if (tempPlayers[currentPlayerIdx].lives <= 0) tempPlayers[currentPlayerIdx].isDead = true; } else { const dmg = lastRoll || 1; tempBossHp -= dmg; playSound('boss_hit'); } } }
                        }
                        if (freshRoom.gameMode === 'gem_hunt' && tempGemLocations.includes(stepPos)) {
                             if (!gemsCollectedThisTurn.includes(stepPos)) { gemsCollectedThisTurn.push(stepPos); tempPlayers[currentPlayerIdx].collectedGems = gemsCollectedThisTurn; tempGemLocations = tempGemLocations.filter(g => g !== stepPos); let newGem = -1; while(newGem === -1 || tempGemLocations.includes(newGem) || newGem === stepPos || newGem === 0 || newGem === 50) newGem = Math.floor(Math.random() * 41) + 5; tempGemLocations.push(newGem); playSound('gem'); }
                        }
                        let intermediateUpdate = { players: tempPlayers };
                        if (freshRoom.gameMode === 'gem_hunt') intermediateUpdate.gemLocations = tempGemLocations;
                        if (freshRoom.gameMode === 'raid_boss') intermediateUpdate.bossHp = tempBossHp;
                        await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), intermediateUpdate);
                        if (!tempGemLocations.includes(stepPos)) playSound('step');
                        await sleep(250 / botSpeed); 
                    }

                    if (tempPlayers[currentPlayerIdx].isDead) { setIsMoving(false); return; }

                    let finalPos = targetPos;
                    let log = `${player.name} è alla ${finalPos}.`;
                    if (collisionLog.length > 0) log += " " + collisionLog.join(" ");

                    if ((freshRoom.gameMode === 'lava' || freshRoom.gameMode === 'glitch' || freshRoom.activeGlitch === 'random_lava' || freshRoom.lavaTiles?.length > 0) && freshRoom.lavaTiles && freshRoom.lavaTiles.includes(finalPos)) {
                        if (tempPlayers[currentPlayerIdx].lives !== undefined) { tempPlayers[currentPlayerIdx].lives -= 1; log += " 🔥 LAVA! -1 VITA!"; playSound('fire'); if (tempPlayers[currentPlayerIdx].lives <= 0) { tempPlayers[currentPlayerIdx].isDead = true; tempPlayers[currentPlayerIdx].finished = true; log += " ELIMINATO!"; playSound('skull'); } }
                    }

                    let special = effectiveSpecials[finalPos];
                    let extraTurns = 0;
                    if (special && !tempPlayers[currentPlayerIdx].isDead) {
                        log += ` ${special.name}!`; 
                        if (special.type === 'BOOST') { 
                            await sleep(500/botSpeed); 
                            finalPos += special.val; 
                            if (isPressure && finalPos > 60) {
                                finalPos = finalPos - 60;
                                tempPlayers[currentPlayerIdx].laps = (tempPlayers[currentPlayerIdx].laps || 0) + 1;
                            }
                            if (finalPos < 0) finalPos = 0; 
                            if (finalPos > config.max && !isPressure) finalPos = config.max; 
                            tempPlayers[currentPlayerIdx].position = finalPos; 
                            playSound('step'); 
                        }
                        else if (special.type === 'JUMP' || special.type === 'BACK' || special.type === 'RESTART') { await sleep(800/botSpeed); finalPos = special.val || 0; tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'DOUBLE') { await sleep(800/botSpeed); const moveAmt = steps.length; finalPos = finalPos + (moveAmt * (targetPos >= currentPos ? 1 : -1)); if (isPressure && finalPos > 60) { finalPos -= 60; tempPlayers[currentPlayerIdx].laps = (tempPlayers[currentPlayerIdx].laps || 0) + 1; } if (finalPos > config.max && !isPressure) finalPos = config.max; if (finalPos < 0) finalPos = 0; tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'TAIL') { await sleep(800/botSpeed); const sortedByPos = [...tempPlayers].filter(p => !p.isDead && !p.finished && (freshRoom.gameMode !== 'sniper' || p.uid !== freshRoom.sniperUid)).sort((a,b) => b.position - a.position); const myRankIdx = sortedByPos.findIndex(p => p.id === player.id); if (myRankIdx > 0) { const targetPlayer = sortedByPos[myRankIdx - 1]; finalPos = Math.max(0, targetPlayer.position - 1); } tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'FRONT') { await sleep(800/botSpeed); const sortedBehind = [...tempPlayers].filter(p => !p.isDead && !p.finished && p.position < finalPos && (freshRoom.gameMode !== 'sniper' || p.uid !== freshRoom.sniperUid)).sort((a,b) => b.position - a.position); if (sortedBehind.length > 0) { const targetPlayer = sortedBehind[0]; finalPos = Math.min(config.max, targetPlayer.position + 1); } tempPlayers[currentPlayerIdx].position = finalPos; playSound('step'); }
                        else if (special.type === 'TELEPORT') { if (freshRoom.gameMode === 'hunter' && isGuard) { log += " (Immune al Teletrasporto)"; } else { await sleep(800/botSpeed); const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (freshRoom.gameMode !== 'relay' || p.teamId !== player.teamId) && (freshRoom.gameMode !== 'sniper' || p.uid !== freshRoom.sniperUid)); if (others.length > 0) { const targetP = others[Math.floor(Math.random() * others.length)]; finalPos = targetP.position; tempPlayers[currentPlayerIdx].position = finalPos; if(isPressure) tempPlayers[currentPlayerIdx].laps = targetP.laps || 0; playSound('teleport'); } } }
                        else if (special.type === 'SWITCH') { if (freshRoom.gameMode === 'hunter' && isGuard) { log += " (Immune allo Switch)"; } else { await sleep(800/botSpeed); const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (freshRoom.gameMode !== 'relay' || p.teamId !== player.teamId) && (freshRoom.gameMode !== 'sniper' || p.uid !== freshRoom.sniperUid)); if (others.length > 0) { const targetP = others[Math.floor(Math.random() * others.length)]; const targetIndex = tempPlayers.findIndex(p => p.id === targetP.id); const myPos = finalPos; const theirPos = targetP.position; tempPlayers[currentPlayerIdx].position = theirPos; tempPlayers[targetIndex].position = myPos; if(isPressure) { const myLaps = tempPlayers[currentPlayerIdx].laps; tempPlayers[currentPlayerIdx].laps = targetP.laps; tempPlayers[targetIndex].laps = myLaps; } await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers }); playSound('teleport'); finalPos = theirPos; } } }
                        else if (special.type === 'DECISION') {
                            if (player.isBot) { const picked = DECISION_POOL[Math.floor(Math.random() * DECISION_POOL.length)]; log += ` Scelta Bot: ${picked.name}!`; if (picked.id === 'turbo') { finalPos = Math.min(finalPos + 4, config.max); tempPlayers[currentPlayerIdx].position = finalPos; } } 
                            else { await sleep(500/botSpeed); const shuffled = [...DECISION_POOL].sort(() => 0.5 - Math.random()); setDecisionOptions(shuffled.slice(0, 3)); setDecisionMode(true); setTargetSelectionMode(null); tempPlayers[currentPlayerIdx].position = finalPos; tempPlayers[currentPlayerIdx].pendingTarget = null; await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers, bossHp: tempBossHp, lastAction: `${player.name} sta scegliendo...` }); setIsMoving(false); return; }
                        }
                        else if (special.type === 'CHALLENGE') {
                            await sleep(500/botSpeed);
                            tempPlayers[currentPlayerIdx].position = finalPos;
                            tempPlayers[currentPlayerIdx].pendingTarget = null;
                            
                            if (player.isBot) {
                                const validTargets = tempPlayers.filter(p => p.uid !== player.uid && !p.finished && !p.isDead);
                                if (validTargets.length > 0) {
                                    const randomTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
                                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                                        duelState: {
                                            active: true,
                                            challengerUid: player.uid,
                                            targetUid: randomTarget.uid,
                                            round: 1,
                                            cWins: 0,
                                            tWins: 0,
                                            cRoll: null,
                                            tRoll: null,
                                            phase: 'waiting_c'
                                        },
                                        players: tempPlayers,
                                        lastAction: `${player.name} HA SFIDATO ${randomTarget.name}!`
                                    });
                                } else {
                                     const nextTurn = getNextTurn({ ...freshRoom, players: tempPlayers }, freshRoom.currentTurn);
                                     await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers, currentTurn: nextTurn, lastAction: `${player.name} non ha nessuno da sfidare!` });
                                }
                                setIsMoving(false); return;
                            } else {
                                setTargetSelectionMode('duel');
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers, lastAction: `${player.name} deve scegliere uno sfidante!` });
                                setIsMoving(false); return;
                            }
                        }
                        else if (special.type === 'EXTRA_DICE') { tempPlayers[currentPlayerIdx].extraDice = true; playSound('powerup'); }
                        if (special.type === 'WAIT') extraTurns = special.turns;
                    }

                    if (freshRoom.gameMode === 'sniper' && freshRoom.sniperTargets && freshRoom.sniperTargets.includes(finalPos)) { if (!isSniper) { tempPlayers[currentPlayerIdx].lives -= 1; log += " 🎯 COLPITO DAL CECCHINO! -1 VITA!"; playSound('sniper'); if (tempPlayers[currentPlayerIdx].lives <= 0) { tempPlayers[currentPlayerIdx].isDead = true; log += " ELIMINATO!"; playSound('skull'); } } }
                    if (finalPos !== targetPos && !tempPlayers[currentPlayerIdx].isDead && freshRoom.gameMode === 'lava' && freshRoom.lavaTiles && freshRoom.lavaTiles.includes(finalPos)) { if (tempPlayers[currentPlayerIdx].lives !== undefined) { tempPlayers[currentPlayerIdx].lives -= 1; log += " 🔥 LAVA! -1 VITA!"; playSound('fire'); if (tempPlayers[currentPlayerIdx].lives <= 0) { tempPlayers[currentPlayerIdx].isDead = true; tempPlayers[currentPlayerIdx].finished = true; log += " ELIMINATO!"; playSound('skull'); } } }
                    if (freshRoom.gameMode === 'black_hole' && finalPos <= freshRoom.blackHolePos) { tempPlayers[currentPlayerIdx].isDead = true; tempPlayers[currentPlayerIdx].finished = true; log += " RISUCCHIATO DAL BUCO NERO!"; playSound('suck'); }
                    if (freshRoom.gameMode === 'classic_punitive' || freshRoom.activeGlitch === 'punitive_round') { const victims = tempPlayers.filter(p => p.id !== player.id && p.position === finalPos && !p.finished && !p.isDead); if (victims.length > 0) { victims.forEach(v => { const vIndex = tempPlayers.findIndex(tp => tp.id === v.id); tempPlayers[vIndex].position = Math.max(0, v.position - 3); }); playSound('punch'); log += " PUNITO!"; } }

                    tempPlayers[currentPlayerIdx] = { ...tempPlayers[currentPlayerIdx], position: finalPos, skipTurns: extraTurns, pendingTarget: null };
                    let updates = { players: tempPlayers, lastAction: log };
                    if (freshRoom.gameMode === 'gem_hunt') updates.gemLocations = tempGemLocations;
                    if (freshRoom.gameMode === 'raid_boss') updates.bossHp = tempBossHp;
                    
                    // ... (rest of logic: win conditions, tournament, next turn) ...
                    let justFinished = false;
                    let hasWon = false;
                    if (freshRoom.gameMode === 'gem_hunt' && tempPlayers[currentPlayerIdx].collectedGems.length >= 5) { hasWon = true; }
                    else if (freshRoom.gameMode === 'reverse') { if (finalPos <= 0 && !tempPlayers[currentPlayerIdx].isDead) hasWon = true; }
                    else if (finalPos === config.max && !tempPlayers[currentPlayerIdx].isDead && !isPressure) { 
                        if (freshRoom.gameMode === 'raid_boss' && isBoss) { updates.status = 'finished'; updates.winner = "IL BOSS HA VINTO!"; playSound('skull'); }
                        else if (freshRoom.gameMode === 'hunter' && isGuard) { tempPlayers[currentPlayerIdx].position = 0; updates.lastAction = (updates.lastAction || "") + " FINE PATTUGLIA! SI RICOMINCIA!"; playSound('teleport'); }
                        else if (freshRoom.gameMode === 'sniper' && isSniper) { }
                        else { hasWon = true; }
                    }

                    if (hasWon) {
                        tempPlayers[currentPlayerIdx].finished = true; playSound('win'); justFinished = true;
                        if (freshRoom.gameMode === 'hunter') { updates.status = 'finished'; updates.winner = "LADRI VINCONO (Uno è scappato)!"; }
                    }
                    
                    if (freshRoom.gameMode === 'raid_boss' && tempBossHp <= 0) { updates.status = 'finished'; updates.winner = "GIOCATORI VINCONO! BOSS SCONFITTO!"; playSound('win'); }
                    
                    const totalPlayers = tempPlayers.length;
                    const finishedPlayers = tempPlayers.filter(p => p.finished);
                    const activePlayers = tempPlayers.filter(p => !p.isDead); 
                    const finishedCount = finishedPlayers.length;

                    if (justFinished) { tempPlayers[currentPlayerIdx].rank = finishedCount; log += " ARRIVATO!"; }

                    // PRESSURE MODE ELIMINATION LOGIC
                    if (freshRoom.gameMode === 'pressure') {
                        const living = tempPlayers.filter(p => !p.isDead);
                        if (living.length === 1 && totalPlayers > 1) {
                            updates.status = 'finished';
                            updates.winner = `${living[0].name} È L'ULTIMO SOPRAVVISSUTO!`;
                            playSound('win');
                        } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn <= currentPlayerIdx) {
                                // New Round
                                const newRound = (freshRoom.round || 1) + 1;
                                updates.round = newRound;
                                
                                if (newRound % 3 === 0) {
                                    // ELIMINATION TIME
                                    // Sort living players by total distance (laps * 60 + pos)
                                    const sorted = [...living].sort((a,b) => {
                                        const distA = (a.laps || 0) * 60 + a.position;
                                        const distB = (b.laps || 0) * 60 + b.position;
                                        return distA - distB; // Ascending: smallest distance first
                                    });
                                    
                                    if (sorted.length > 0) {
                                        const victim = sorted[0];
                                        const vIndex = tempPlayers.findIndex(p => p.uid === victim.uid);
                                        tempPlayers[vIndex].isDead = true;
                                        tempPlayers[vIndex].lives = 0;
                                        log += ` 💀 ${victim.name} ELIMINATO DALLA PRESSIONE!`;
                                        playSound('skull');
                                        updates.players = tempPlayers;
                                        
                                        if (living.length - 1 === 1 && totalPlayers > 1) {
                                             updates.status = 'finished';
                                             updates.winner = `${sorted[1].name} VINCE LA PRESSIONE!`;
                                             playSound('win');
                                        }
                                    }
                                }
                            }
                            updates.currentTurn = nextTurn;
                        }
                    } else if (freshRoom.gameMode === 'tournament' && justFinished) {
                        const pointsMap = TOURNAMENT_POINTS;
                        const points = pointsMap[finishedCount - 1] || 1;
                        tempPlayers[currentPlayerIdx].score = (tempPlayers[currentPlayerIdx].score || 0) + points;
                        log += ` +${points} PUNTI!`;
                        
                        // Check if round finished
                        const activeAlive = tempPlayers.filter(p => !p.isDead);
                        const allFinished = activeAlive.every(p => p.finished);
                        
                        if (allFinished) {
                            if (freshRoom.round < freshRoom.tournamentTotalRounds) {
                                // Next Round
                                tempPlayers.forEach(p => { 
                                    if (!p.isDead) {
                                        p.position = 0; 
                                        p.finished = false; 
                                    }
                                });
                                updates.round = (freshRoom.round || 1) + 1;
                                log += " ROUND COMPLETATO!";
                                updates.players = tempPlayers;
                                updates.lastAction = log;
                                updates.currentTurn = 0;
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                                setIsMoving(false);
                                return;
                            } else {
                                // Tournament Over
                                const winner = [...tempPlayers].sort((a,b) => (b.score || 0) - (a.score || 0))[0];
                                updates.status = 'finished';
                                updates.winner = `${winner.name} VINCE CON ${winner.score} PUNTI!`;
                            }
                        }
                    }

                    else if (freshRoom.gameMode === 'battle_royale' && justFinished) {
                        if (finishedCount >= freshRoom.qualifyLimit) {
                            const brRound = freshRoom.battleRoundIndex || 0;
                            tempPlayers = tempPlayers.map(p => { if (!p.finished && !p.isDead) { return { ...p, isDead: true, rank: 999 }; } return p; });
                            if (freshRoom.qualifyLimit === 1) { updates.status = 'finished'; updates.winner = `${player.name} VINCE LA BATTLE ROYALE!`; } 
                            else {
                                const config = freshRoom.battleRoundConfig || [];
                                let nextLimit = 1; if (config.length > brRound + 1) { nextLimit = config[brRound + 1]; }
                                tempPlayers = tempPlayers.map(p => { if (p.finished && !p.isDead) { return { ...p, finished: false, position: 0, pendingTarget: null }; } return p; });
                                updates.battleRoundIndex = brRound + 1; updates.qualifyLimit = nextLimit; updates.round = (freshRoom.round || 1) + 1; updates.lastAction = `ROUND ${brRound+1} FINITO! PROSSIMO: QUALIFICANO ${nextLimit}`; updates.players = tempPlayers; updates.currentTurn = getNextTurn(tempPlayers, -1);
                            }
                        } else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); updates.currentTurn = nextTurn; }
                    } else if (freshRoom.gameMode === 'battle_royale') { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); updates.currentTurn = nextTurn; }
                    else if (freshRoom.gameMode === 'relay') { const teams = freshRoom.teamConfig.teams; const finishedTeams = []; for(let t=0; t<teams; t++) { if (checkTeamWin(tempPlayers, t)) finishedTeams.push(t); } if (finishedTeams.length >= teams - 1 && teams > 1) { updates.status = 'finished'; updates.winner = "GARA COMPLETATA"; } else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); updates.currentTurn = nextTurn; } } 
                    else if (freshRoom.gameMode === 'hunter') { const thieves = tempPlayers.filter(p => p.uid !== freshRoom.guardUid); const livingThieves = thieves.filter(p => !p.isDead); if (livingThieves.length === 0) { updates.status = 'finished'; updates.winner = "GUARDIA VINCE (Tutti arrestati)!"; } else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); updates.currentTurn = nextTurn; } } 
                    else if (freshRoom.gameMode === 'elimination') {
                        const living = tempPlayers.filter(p => !p.isDead); const finishedLiving = living.filter(p => p.finished);
                        if (finishedLiving.length === living.length - 1 && living.length > 1) { const loser = living.find(p => !p.finished); const loserIndex = tempPlayers.findIndex(p => p.id === loser.id); tempPlayers[loserIndex].isDead = true; tempPlayers.forEach(p => { if (!p.isDead) { p.position = 0; p.finished = false; } }); updates.players = tempPlayers; updates.round = freshRoom.round + 1; updates.customSpecials = generateEliminationSpecials(); updates.currentTurn = 0; } 
                        else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); updates.currentTurn = nextTurn; }
                    } else if (freshRoom.gameMode === 'raid_boss') {
                        const livingRaiders = tempPlayers.filter(p => p.uid !== freshRoom.hostId && !p.isDead); if (livingRaiders.length === 0) { updates.status = 'finished'; updates.winner = "BOSS HA VINTO (TUTTI MORTI)!"; } else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); if (nextTurn <= currentPlayerIdx) { updates.round = (freshRoom.round || 1) + 1; updates.bossTargetUid = null; } updates.currentTurn = nextTurn; }
                    } else if (freshRoom.gameMode === 'sniper') {
                        const livingRunners = tempPlayers.filter(p => p.uid !== freshRoom.sniperUid && !p.isDead); if (livingRunners.length === 0) { updates.status = 'finished'; updates.winner = "CECCHINO HA VINTO (TUTTI MORTI)!"; } else if (finishedCount > 0) { updates.status = 'finished'; updates.winner = "I CORRIDORI VINCONO!"; } else { const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx); if (nextTurn <= currentPlayerIdx) { updates.round = (freshRoom.round || 1) + 1; updates.sniperTargets = []; } updates.currentTurn = nextTurn; }
                    } else if (freshRoom.gameMode === 'lava' || freshRoom.gameMode === 'black_hole') {
                        const living = tempPlayers.filter(p => !p.isDead); const arrived = living.filter(p => p.finished);
                        if (arrived.length >= living.length - 1 && living.length > 1) { updates.status = 'finished'; updates.winner = "GARA TERMINATA!"; } else if (living.length === 0) { updates.status = 'finished'; updates.winner = "NESSUN SOPRAVVISSUTO!"; } else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn <= currentPlayerIdx) {
                                updates.round = (freshRoom.round || 1) + 1;
                                if (freshRoom.gameMode === 'lava') { let newLava = -1; const existingLava = freshRoom.lavaTiles || []; let attempts = 0; while((newLava === -1 || newLava === 0 || newLava === 60 || existingLava.includes(newLava)) && attempts < 100) { newLava = Math.floor(Math.random() * 59) + 1; attempts++; } if (newLava !== -1) { updates.lavaTiles = [...existingLava, newLava]; updates.lastAction = `ROUND ${updates.round}: LAVA A ${newLava}!`; playSound('fire'); } }
                                if (freshRoom.gameMode === 'black_hole') { const moveAmt = ((freshRoom.round - 1) % 6) + 1; updates.blackHolePos = (freshRoom.blackHolePos || 0) + moveAmt; updates.lastAction = `ROUND ${updates.round}: BUCO NERO AVANZA DI ${moveAmt}!`; playSound('suck'); tempPlayers = tempPlayers.map(p => { if (p.position <= updates.blackHolePos && !p.finished && !p.isDead) { return { ...p, isDead: true, finished: true }; } return p; }); updates.players = tempPlayers; }
                            }
                            updates.currentTurn = nextTurn;
                        }
                    } else if (freshRoom.gameMode !== 'tournament' && freshRoom.gameMode !== 'pressure') {
                        if (finishedCount >= totalPlayers - 1 && totalPlayers > 1) { updates.status = 'finished'; updates.winner = "TUTTI ARRIVATI!"; } 
                        else {
                            const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                            if (nextTurn <= currentPlayerIdx) {
                                updates.round = (freshRoom.round || 1) + 1;
                                if (freshRoom.gameMode === 'glitch') {
                                    if (updates.round % 3 === 0) {
                                        const glitches = ['gravity', 'darkness', 'earthquake', 'swap', 'rewind', 'cursed', 'double_dice', 'random_lava', 'black_hole_spawn', 'punitive_round'];
                                        const selected = glitches[Math.floor(Math.random() * glitches.length)];
                                        updates.activeGlitch = selected;
                                        let glitchMsg = ""; if (selected === 'gravity') glitchMsg = "GRAVITÀ BASSA!"; if (selected === 'darkness') glitchMsg = "BUIO TOTALE!"; if (selected === 'earthquake') glitchMsg = "TERREMOTO!"; if (selected === 'swap') glitchMsg = "SCAMBIO POSIZIONI!"; if (selected === 'rewind') glitchMsg = "REWIND (-5)!"; if (selected === 'cursed') glitchMsg = "DADI MALEDETTI!"; if (selected === 'double_dice') glitchMsg = "DOPPI DADI!"; if (selected === 'random_lava') glitchMsg = "IL SUOLO È LAVA!"; if (selected === 'black_hole_spawn') glitchMsg = "SINGOLARITÀ!"; if (selected === 'punitive_round') glitchMsg = "COLLISIONI PUNITIVE!";
                                        updates.lastAction = `GLITCH ATTIVATO: ${glitchMsg}`; playSound('glitch');
                                        if (selected === 'earthquake') { tempPlayers = tempPlayers.map(p => { if(p.isDead || p.finished) return p; const shift = Math.floor(Math.random() * 7) - 3; return { ...p, position: Math.max(0, Math.min(60, p.position + shift)) }; }); updates.players = tempPlayers; } 
                                        else if (selected === 'rewind') { tempPlayers = tempPlayers.map(p => { if(p.isDead || p.finished) return p; return { ...p, position: Math.max(0, p.position - 5) }; }); updates.players = tempPlayers; } 
                                        else if (selected === 'swap') { const activeIndices = tempPlayers.map((p, i) => ({...p, idx: i})).filter(p => !p.isDead && !p.finished); if (activeIndices.length > 1) { const positions = activeIndices.map(p => p.position); const lastPos = positions.pop(); positions.unshift(lastPos); activeIndices.forEach((p, i) => { tempPlayers[p.idx].position = positions[i]; }); updates.players = tempPlayers; } } 
                                        else if (selected === 'random_lava') { let newLava = -1; const existingLava = freshRoom.lavaTiles || []; let attempts = 0; while((newLava === -1 || newLava === 0 || newLava === 60 || existingLava.includes(newLava)) && attempts < 100) { newLava = Math.floor(Math.random() * 59) + 1; attempts++; } if (newLava !== -1) { updates.lavaTiles = [...existingLava, newLava]; } } 
                                        else if (selected === 'black_hole_spawn') { const newBlackHolePos = (freshRoom.blackHolePos || 0) + 3; updates.blackHolePos = newBlackHolePos; tempPlayers = tempPlayers.map(p => { if (p.position <= newBlackHolePos && !p.finished && !p.isDead) { return { ...p, isDead: true, finished: true }; } return p; }); updates.players = tempPlayers; playSound('suck'); }
                                    } else { updates.activeGlitch = null; updates.lastAction = `ROUND ${updates.round}: Glitch Disattivato.`; }
                                }
                                if (freshRoom.gameMode === 'infection' && updates.round > 3) { const infectionSteps = [2, 3, 5, 7, 8]; const roll = infectionSteps[Math.floor(Math.random() * infectionSteps.length)]; const oldNpcPos = freshRoom.infectedNPC.position; const newNpcPos = oldNpcPos + roll; updates['infectedNPC.position'] = newNpcPos; updates['infectedNPC.lastMovedRound'] = updates.round; let killCount = 0; tempPlayers = tempPlayers.map(p => { if (!p.isDead && !p.finished && p.position <= newNpcPos) { killCount++; return { ...p, isDead: true, position: 0 }; } return p; }); updates.players = tempPlayers; updates.lastAction = `ROUND ${updates.round}: Virus avanza di ${roll}! ${killCount > 0 ? killCount + ' presi!' : ''}`; playSound('zombie'); }
                            }
                            updates.currentTurn = nextTurn;
                        }
                    } else {
                        // Tournament mode turn logic (if not everyone finished)
                        const nextTurn = getNextTurn(tempPlayers, currentPlayerIdx);
                        updates.currentTurn = nextTurn;
                    }

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                } catch (e) { handleError(e); } finally {
                    setIsRolling(false);
                    setIsMoving(false); // Ensure moving lock is released even if error
                }
            };
            
            // ... (confirmGemMove, handleDecisionEffect logic preserved) ...
            
             const confirmGemMove = async (dir) => {
                 if (!directionChoice) return;
                 const playerIdx = currentRoom.currentTurn;
                 const player = currentRoom.players[playerIdx];
                 let newPos = player.position + (directionChoice.val * dir);
                 if (newPos > 50) newPos = 50; if (newPos < 0) newPos = 0;
                 const updated = [...currentRoom.players];
                 updated[playerIdx] = { ...player, pendingTarget: newPos };
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
                 setDirectionChoice(null);
            };

            const handleDecisionEffect = async (option) => {
                if (!option || !currentRoom) return;
                const playerIdx = currentRoom.currentTurn;
                const player = currentRoom.players[playerIdx];
                if (option.id === 'target_back_4' || option.id === 'curse' || option.id === 'vampire' || option.id === 'force_stop' || option.id === 'targeted_swap') { setTargetSelectionMode(option.id); return; }
                
                let updatedPlayers = [...currentRoom.players];
                updatedPlayers[playerIdx] = { ...updatedPlayers[playerIdx], pendingTarget: null };

                if (option.id === 'leadership') { updatedPlayers = updatedPlayers.map(p => { if (p.isDead || p.finished || (currentRoom.gameMode === 'sniper' && p.uid === currentRoom.sniperUid)) return p; let move = (p.id === player.id) ? 4 : 2; return { ...p, position: Math.min(p.position + move, 60) }; }); }
                else if (option.id === 'teleport') { const others = updatedPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished && (currentRoom.gameMode !== 'relay' || p.teamId !== player.teamId) && (currentRoom.gameMode !== 'sniper' || p.uid !== currentRoom.sniperUid)); if (others.length > 0) { const target = others[Math.floor(Math.random() * others.length)]; updatedPlayers[playerIdx].position = target.position; playSound('teleport'); } }
                else if (option.id === 'reroll') { setDecisionMode(false); setDecisionOptions([]); await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, lastAction: `${player.name} tira di nuovo!` }); return; }
                else if (option.id === 'turbo') { updatedPlayers[playerIdx].position = Math.min(player.position + 5, 60); }
                else if (option.id === 'anchor') { updatedPlayers = updatedPlayers.map(p => { if (p.isDead || p.finished || p.id === player.id) return p; return { ...p, position: Math.max(0, p.position - 2) }; }); playSound('punch'); }
                else if (option.id === 'gamble') { const win = Math.random() > 0.5; const val = win ? 6 : -3; updatedPlayers[playerIdx].position = Math.max(0, Math.min(60, player.position + val)); playSound(win ? 'powerup' : 'lose'); await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, lastAction: `${player.name} SCOMMETTE E... ${win ? 'VINCE (+6)!' : 'PERDE (-3)!'}` }); setDecisionMode(false); setDecisionOptions([]); return; }
                
                setDecisionMode(false); setDecisionOptions([]);
                const nextTurn = getNextTurn(updatedPlayers, playerIdx);
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, currentTurn: nextTurn, lastAction: `${player.name} usa ${option.name}!` });
            };

            const handleTargetClick = async (targetUid) => {
                if (bossTargetSelection) { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { bossTargetUid: targetUid }); setBossTargetSelection(false); return; }
                if (!targetSelectionMode || !currentRoom) return;
                const targetIdx = currentRoom.players.findIndex(p => p.uid === targetUid);
                const playerIdx = currentRoom.currentTurn;
                if (targetIdx === -1 || targetIdx === playerIdx) return;
                let updatedPlayers = [...currentRoom.players];
                updatedPlayers[playerIdx] = { ...updatedPlayers[playerIdx], pendingTarget: null };
                
                if (targetSelectionMode === 'target_back_4') { updatedPlayers[targetIdx].position = Math.max(0, updatedPlayers[targetIdx].position - 4); playSound('punch'); }
                else if (targetSelectionMode === 'curse') { updatedPlayers[targetIdx].activeCurse = true; playSound('curse'); }
                else if (targetSelectionMode === 'vampire') { updatedPlayers[targetIdx].position = Math.max(0, updatedPlayers[targetIdx].position - 3); updatedPlayers[playerIdx].position = Math.min(60, updatedPlayers[playerIdx].position + 3); playSound('suck'); }
                else if (targetSelectionMode === 'force_stop') { updatedPlayers[targetIdx].skipTurns = (updatedPlayers[targetIdx].skipTurns || 0) + 1; playSound('lock'); }
                else if (targetSelectionMode === 'targeted_swap') { const myPos = updatedPlayers[playerIdx].position; updatedPlayers[playerIdx].position = updatedPlayers[targetIdx].position; updatedPlayers[targetIdx].position = myPos; playSound('teleport'); }
                else if (targetSelectionMode === 'duel') {
                    // Start Duel Mode
                    const challenger = updatedPlayers[playerIdx];
                    const target = updatedPlayers[targetIdx];
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        duelState: {
                            active: true,
                            challengerUid: challenger.uid,
                            targetUid: target.uid,
                            round: 1,
                            cWins: 0,
                            tWins: 0,
                            cRoll: null,
                            tRoll: null,
                            phase: 'waiting_c' // waiting for challenger roll
                        },
                        players: updatedPlayers,
                        lastAction: `${challenger.name} HA SFIDATO ${target.name}!`
                    });
                    setTargetSelectionMode(null);
                    return; // Don't advance turn yet
                }
                
                setTargetSelectionMode(null); setDecisionMode(false); setDecisionOptions([]);
                const nextTurn = getNextTurn(updatedPlayers, playerIdx);
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updatedPlayers, currentTurn: nextTurn, lastAction: `${updatedPlayers[playerIdx].name} ha completato l'azione!` });
            };

            const processDuelStep = async (role) => {
                if (!currentRoom || !currentRoom.duelState) return;
                const duel = currentRoom.duelState;
                const roll = Math.floor(Math.random() * 6) + 1;
                playSound('roll');

                let updates = {};
                let log = "";

                if (role === 'challenger' && duel.phase === 'waiting_c') {
                    updates = {
                        'duelState.cRoll': roll,
                        'duelState.phase': 'waiting_t'
                    };
                } else if (role === 'target' && duel.phase === 'waiting_t') {
                    // Target rolls, compare logic
                    const cRoll = duel.cRoll;
                    const tRoll = roll;
                    let newCWins = duel.cWins;
                    let newTWins = duel.tWins;
                    let winnerName = "";
                    
                    if (cRoll > tRoll) { newCWins++; winnerName = "Sfidante"; }
                    else if (tRoll > cRoll) { newTWins++; winnerName = "Avversario"; }
                    else { /* Tie, no points or handled as draw */ }

                    // Check if match ends
                    // Best of 3: if someone reaches 2 wins, or after 3 rounds
                    let duelOver = false;
                    let finalWinner = null; // 'challenger' or 'target'

                    if (newCWins >= 2) { duelOver = true; finalWinner = 'challenger'; }
                    else if (newTWins >= 2) { duelOver = true; finalWinner = 'target'; }
                    else if (duel.round >= 3) {
                        duelOver = true;
                        if (newCWins > newTWins) finalWinner = 'challenger';
                        else if (newTWins > newCWins) finalWinner = 'target';
                        else finalWinner = 'draw'; // Draw (usually challenger loses benefit or nothing happens)
                    }

                    if (duelOver) {
                        // Apply Effects
                        let players = [...currentRoom.players];
                        const cIdx = players.findIndex(p => p.uid === duel.challengerUid);
                        const tIdx = players.findIndex(p => p.uid === duel.targetUid);
                        const configMax = (currentRoom.gameMode === 'battle_royale' ? 40 : (currentRoom.gameMode === 'brawl' ? 64 : (currentRoom.gameMode === 'elimination' ? 34 : (currentRoom.gameMode === 'gem_hunt' ? 50 : 60))));

                        if (finalWinner === 'challenger') {
                            players[cIdx].position = Math.min(configMax, players[cIdx].position + 6);
                            log = `${players[cIdx].name} VINCE IL DUELLO! (+6)`;
                            playSound('win');
                        } else {
                            // Target wins or draw (challenger fails)
                            players[cIdx].position = Math.max(0, players[cIdx].position - 3);
                            players[tIdx].position = Math.min(configMax, players[tIdx].position + 3);
                            log = `${players[cIdx].name} PERDE IL DUELLO! (-3, Avversario +3)`;
                            playSound('lose');
                        }

                        updates = {
                            duelState: null,
                            players: players,
                            lastAction: log,
                            currentTurn: getNextTurn(players, currentRoom.currentTurn)
                        };
                    } else {
                        // Next Round
                        updates = {
                            'duelState.cWins': newCWins,
                            'duelState.tWins': newTWins,
                            'duelState.round': duel.round + 1,
                            'duelState.phase': 'waiting_c',
                            'duelState.cRoll': null,
                            'duelState.tRoll': null
                        };
                    }
                }
                
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
            };
            
            // ... (rest of the file: handleSniperTileClick, confirmSniperShot, useEffect, updateBrConfig, handleRoll, toggleBotMode, getNextTurn, autoBot useEffect, UI Rendering) ...
            
            const handleSniperTileClick = (idx) => { if (currentRoom.gameMode !== 'sniper' || !canControlCurrent) return; let newSelection = [...sniperSelection]; if (newSelection.includes(idx)) newSelection = newSelection.filter(i => i !== idx); else if (newSelection.length < 3) newSelection.push(idx); setSniperSelection(newSelection); };
            const confirmSniperShot = async () => { if (sniperSelection.length === 0) return; const playerIdx = currentRoom.currentTurn; const player = currentRoom.players[playerIdx]; await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { sniperTargets: sniperSelection, lastAction: `${player.name} ha mirato su ${sniperSelection.length} caselle!`, currentTurn: getNextTurn(currentRoom.players, playerIdx) }); setSniperSelection([]); };

            useEffect(() => {
                if (currentRoom && currentRoom.gameMode === 'battle_royale' && currentRoom.battleRoundConfig && !brConfigInput) { setBrConfigInput(currentRoom.battleRoundConfig.join(", ")); }
            }, [currentRoom]);

            const updateBrConfig = async (val) => { setBrConfigInput(val); const nums = val.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n > 0); if (nums.length > 0 && currentRoom) { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { battleRoundConfig: nums }); } }

            const handleRoll = async () => {
                if (isRolling || isMoving || !currentRoom) return;
                
                // Force reset lock if it gets stuck for too long (safety mechanism)
                const rollSafety = setTimeout(() => {
                     if (isRolling) { setIsRolling(false); }
                }, 3000);

                try {
                    setIsRolling(true); playSound('step');
                    
                    // FETCH FRESH DATA FIRST
                    const snap = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode));
                    if (!snap.exists()) return;
                    const freshRoom = snap.data();
                    
                    const playerIdx = freshRoom.currentTurn;
                    const player = freshRoom.players[playerIdx];
                    const me = freshRoom.players.find(p => p.uid === user.uid);
                    
                    const teamMode = freshRoom.teamBotModes?.[player.teamId] || 'auto';
                    const isAutoBot = player.isBot && teamMode === 'auto' && freshRoom.hostId === user.uid;
                    const isMyTeamManualBot = player.isBot && freshRoom.gameMode === 'relay' && me && player.teamId === me.teamId && teamMode === 'manual';
                    const isHostControllingBot = player.isBot && freshRoom.gameMode !== 'relay' && freshRoom.hostId === user.uid;
                    
                    // Logic check with FRESH data
                    if (player.uid !== user.uid && !isMyTeamManualBot && !isAutoBot && !isHostControllingBot) {
                        return;
                    }

                    // --- CRITICAL FIX: Stop if dead or finished ---
                    if (player.isDead || player.finished) {
                        setIsRolling(false);
                        return;
                    }
                    
                    if (isPawnLocked(player, freshRoom.players)) { await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { currentTurn: getNextTurn(freshRoom.players, playerIdx) }); return; }
                    if (player.skipTurns > 0) { let updated = [...freshRoom.players]; updated[playerIdx].skipTurns -= 1; await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated, currentTurn: getNextTurn(updated, playerIdx) }); return; }
                    
                    const isBoss = freshRoom.gameMode === 'raid_boss' && player.uid === freshRoom.hostId;
                    const isGuard = freshRoom.gameMode === 'hunter' && player.uid === freshRoom.guardUid;
                    const isSniper = freshRoom.gameMode === 'sniper' && player.uid === freshRoom.sniperUid;
                    const isReverse = freshRoom.gameMode === 'reverse';
                    const isPressure = freshRoom.gameMode === 'pressure';

                    if (isSniper) return;

                    let vals = [];
                    if (isBoss) { vals = BOSS_DICE_VALS; } else if (freshRoom.activeGlitch === 'cursed') { vals = [-3, -2, -1, 1, 2, 3]; } else { const charId = (player.characterId >= 0 && player.characterId < ROSTER.length) ? player.characterId : 0; const specialDice = ROSTER[charId].dice; vals = player.activeCurse ? [-3, -2, -1, 0, 1, 2] : (useSpecialDie ? specialDice.vals : [1,2,3,4,5,6]); }

                    for(let i=0; i<8; i++) { setLastRoll(vals[Math.floor(Math.random() * vals.length)]); await sleep(40/botSpeed); }
                    let val = vals[Math.floor(Math.random() * vals.length)];
                    
                    if (player.extraDice) { val += Math.floor(Math.random() * 6) + 1; }
                    
                    if (isGuard) val += 2;
                    if (freshRoom.activeGlitch === 'gravity') val = val * 2; 
                    if (freshRoom.activeGlitch === 'double_dice') val += Math.floor(Math.random() * 6) + 1; 

                    setLastRoll(val); 
                    await sleep(150/botSpeed);
                    let updated = [...freshRoom.players];
                    updated[playerIdx].activeCurse = false;
                    updated[playerIdx].extraDice = false;
                    
                    if (freshRoom.gameMode === 'gem_hunt') { val = Math.abs(val); setDirectionChoice({ val }); return; }
                    
                    if (freshRoom.gameMode === 'tiles' || freshRoom.gameMode === 'coin_collector' || freshRoom.gameMode === 'brawl') {
                         val = Math.abs(val); updated[playerIdx].remainingMoves = val; setIsRolling(false);
                         await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated, lastAction: `${player.name} ha ${val} passi! Clicca sulle caselle vicine!` }); return;
                    }

                    const config = freshRoom.gameMode === 'elimination' ? ELIM_MAP : (freshRoom.gameMode === 'gem_hunt' ? GEM_MAP : (freshRoom.gameMode === 'reverse' ? REVERSE_MAP : (freshRoom.gameMode === 'battle_royale' ? BATTLE_ROYALE_MAP : (freshRoom.gameMode === 'hunter' ? HUNTER_MAP : CLASSIC_MAP))));
                    const maxVal = config.max !== undefined ? config.max : 60;
                    
                    let newPos; 
                    if (isReverse) { 
                        newPos = Math.max(0, player.position - val); 
                    } else if (isPressure) {
                        // Logic for infinite map is handled in executeMove, 
                        // here we just set the target. We wrap only for calculation 
                        // but store the "virtual" higher number or handle wrap in movement
                        // Actually better to calculate raw target here
                        newPos = player.position + val; 
                    } else { 
                        newPos = Math.max(0, Math.min(maxVal, player.position + val)); 
                    }
                    
                    updated[playerIdx].pendingTarget = newPos;
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated, lastAction: `${player.name} fa ${val}!` });
                } catch (e) { handleError(e); } finally {
                    // Safe reset
                    clearTimeout(rollSafety);
                    if (currentRoom.gameMode !== 'gem_hunt' && currentRoom.gameMode !== 'tiles' && currentRoom.gameMode !== 'coin_collector' && currentRoom.gameMode !== 'brawl') {
                        setIsRolling(false);
                    }
                }
            };

            const toggleBotMode = async () => { if (!currentRoom || !me) return; const currentMode = currentRoom.teamBotModes?.[me.teamId] || 'auto'; const newMode = currentMode === 'auto' ? 'manual' : 'auto'; await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { [`teamBotModes.${me.teamId}`]: newMode }); };

            const getNextTurn = (players, currentIdx) => {
                let next = (currentIdx + 1) % players.length;
                let loop = 0;
                while(loop < players.length && (players[next].isDead || players[next].finished || isPawnLocked(players[next], players))) {
                    next = (next + 1) % players.length; 
                    loop++;
                }
                return next;
            };
            
            // --- FIX: Force Next Turn (Manual Debug) ---
            const forceNextTurn = async () => {
                if (!currentRoom || !user || currentRoom.hostId !== user.uid) return;
                try {
                    const nextTurn = getNextTurn(currentRoom.players, currentRoom.currentTurn);
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        currentTurn: nextTurn,
                        lastAction: "TURNO FORZATO DAL HOST!"
                    });
                    // Reset local locks just in case
                    setIsRolling(false);
                    setIsMoving(false);
                } catch (e) { handleError(e); }
            };

            // AUTO-BOT & DUEL BOT LOGIC
            useEffect(() => {
                if (currentRoom?.status === 'playing') {
                    // DUEL LOGIC FOR BOTS
                    if (currentRoom.duelState && currentRoom.duelState.active && currentRoom.hostId === user?.uid) {
                        const duel = currentRoom.duelState;
                        const challenger = currentRoom.players.find(p => p.uid === duel.challengerUid);
                        const target = currentRoom.players.find(p => p.uid === duel.targetUid);
                        
                        if (duel.phase === 'waiting_c' && challenger.isBot) {
                            const t = setTimeout(() => processDuelStep('challenger'), 1000);
                            return () => clearTimeout(t);
                        } else if (duel.phase === 'waiting_t' && target.isBot) {
                            const t = setTimeout(() => processDuelStep('target'), 1000);
                            return () => clearTimeout(t);
                        }
                    }

                    const p = currentRoom.players[currentRoom.currentTurn];
                    if (!p) return;
                    
                    // Prevent bot re-triggering for the same turn if already handled locally
                    const turnKey = `${currentRoom.currentTurn}-${p.uid}`;
                    
                    // Reset ref if turn changed
                    if (lastBotTurnRef.current.turn !== currentRoom.currentTurn) {
                        lastBotTurnRef.current = { turn: currentRoom.currentTurn, timestamp: Date.now() };
                    }

                    const teamMode = currentRoom.teamBotModes?.[p.teamId] || 'auto';
                    const shouldAutoRun = p.isBot && currentRoom.hostId === user?.uid && !isRolling && !isMoving && !decisionMode && !directionChoice && teamMode === 'auto';
                    const botMode = currentRoom.teamBotModes?.[p.uid] || 'auto';
                    const isGenericBot = p.isBot && currentRoom.gameMode !== 'relay' && currentRoom.hostId === user?.uid && !isRolling && !isMoving && !decisionMode && !directionChoice && botMode === 'auto';

                    if (!currentRoom.duelState && ((currentRoom.gameMode === 'relay' && shouldAutoRun) || (currentRoom.gameMode !== 'relay' && isGenericBot))) {
                        // Reduced Delays for Snappier Bots
                        const delay = 1000 / botSpeed; 
                        const moveDelay = 500 / botSpeed;
                        
                        // Safety: Don't run logic for dead bots
                        if (p.isDead || p.finished) return;

                        if (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl') {
                             if (!isRolling && (!p.remainingMoves || p.remainingMoves <= 0)) { const t = setTimeout(() => handleRoll(), delay); return () => clearTimeout(t); } 
                             else if (p.remainingMoves > 0) {
                                  let target = -1;
                                  const width = getGridWidth(currentRoom.gameMode);
                                  const validMoves = [];
                                  
                                  for(let i=0; i<(currentRoom.gameMode === 'brawl' ? 64 : 121); i++) { if(getManhattanDistance(p.position, i, width) === 1) { if (currentRoom.gameMode === 'brawl') { const isVoid = currentRoom.voidTiles && currentRoom.voidTiles.includes(i); const isLava = currentRoom.lavaTiles && currentRoom.lavaTiles.includes(i); if (!isVoid && !isLava) validMoves.push(i); } else { validMoves.push(i); } } }
                                  
                                  if (currentRoom.gameMode === 'coin_collector' && currentRoom.coinLocations) { const reachableCoins = currentRoom.coinLocations.filter(c => getManhattanDistance(p.position, c.pos, width) === 1); if (reachableCoins.length > 0) { target = reachableCoins[0].pos; } }
                                  if (target === -1 && validMoves.length > 0) { target = validMoves[Math.floor(Math.random() * validMoves.length)]; }
                                  
                                  if (target !== -1) { const t = setTimeout(() => executeTileMove(p.uid, target), moveDelay); return () => clearTimeout(t); }
                             }
                        } else {
                            // Classic Movement Logic
                            if (p.pendingTarget === null) { 
                                // ROLL PHASE
                                // Only roll if we haven't rolled recently or if it's clearly a new attempt needed
                                const t = setTimeout(() => handleRoll(), delay); 
                                return () => clearTimeout(t); 
                            } else { 
                                // MOVE PHASE
                                // Execute move if pending target exists
                                const t = setTimeout(() => executeMove(p.uid, p.pendingTarget), delay); 
                                return () => clearTimeout(t); 
                            }
                        }
                    }
                }
            }, [currentRoom?.currentTurn, currentRoom?.status, currentRoom?.duelState, isRolling, isMoving, user, directionChoice, decisionMode, botSpeed]);

            if (!user) return <div className="h-screen flex items-center justify-center bg-slate-900 text-white font-black">MULTIVERSE RUN</div>;
            // ... (rest of the component render logic is preserved) ...
            const currentPlayer = currentRoom?.players?.[currentRoom.currentTurn];
            const me = currentRoom?.players?.find(p => p.uid === user.uid);
            
            const myTeamPlayers = currentRoom?.players?.filter(p => !p.isBot && p.teamId === me?.teamId) || [];
            const isLeader = myTeamPlayers.length > 0 && myTeamPlayers[0].uid === user.uid;

            const teamMode = currentRoom?.teamBotModes?.[currentPlayer?.teamId] || 'auto';
            const genericBotMode = currentRoom?.teamBotModes?.[currentPlayer?.uid] || 'auto';
            
            const canControlCurrent = currentPlayer && (
                currentPlayer.uid === user.uid || 
                (currentPlayer.isBot && currentRoom.gameMode === 'relay' && me && currentPlayer.teamId === me.teamId && teamMode === 'manual') ||
                (currentPlayer.isBot && currentRoom.gameMode !== 'relay' && currentRoom.hostId === user.uid && genericBotMode === 'manual')
            );
            
            const isSniperTurn = currentRoom?.gameMode === 'sniper' && currentPlayer?.uid === currentRoom?.sniperUid && canControlCurrent;

            // --- DUEL CONSTANTS ---
            const duelActive = currentRoom?.duelState && currentRoom.duelState.active;
            const duelData = duelActive ? currentRoom.duelState : null;
            const duelChallenger = duelActive ? currentRoom.players.find(p => p.uid === duelData.challengerUid) : null;
            const duelTarget = duelActive ? currentRoom.players.find(p => p.uid === duelData.targetUid) : null;
            const isChallengerTurn = duelActive && duelData.phase === 'waiting_c';
            const isTargetTurn = duelActive && duelData.phase === 'waiting_t';
            const canControlDuel = duelActive && (
                (isChallengerTurn && (duelChallenger.uid === user.uid || (duelChallenger.isBot && currentRoom.hostId === user.uid))) ||
                (isTargetTurn && (duelTarget.uid === user.uid || (duelTarget.isBot && currentRoom.hostId === user.uid)))
            );

            return (
                <div className="min-h-screen bg-slate-50 text-slate-800 font-sans flex flex-col relative">
                
                {/* DUEL MODAL */}
                {duelActive && duelChallenger && duelTarget && (
                    <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md animate-in fade-in">
                        <div className="max-w-lg w-full bg-slate-900 rounded-3xl shadow-2xl border-4 border-amber-500 overflow-hidden relative">
                             <div className="bg-amber-500 p-4 text-center">
                                 <h2 className="text-3xl font-black text-black uppercase flex items-center justify-center gap-2"><SwordsIcon size={32}/> DUELLO!</h2>
                                 <p className="font-bold text-amber-900 uppercase">Round {duelData.round} / 3</p>
                             </div>
                             
                             <div className="p-8 flex items-center justify-between">
                                 {/* CHALLENGER SIDE */}
                                 <div className={`flex flex-col items-center gap-2 transition-all ${isChallengerTurn ? 'scale-110 opacity-100' : 'opacity-50'}`}>
                                     <div className={`p-2 rounded-full border-4 ${isChallengerTurn ? 'border-amber-400 shadow-[0_0_20px_orange]' : 'border-slate-600'}`}>
                                         <PlayerAvatar charId={duelChallenger.characterId} size="lg"/>
                                     </div>
                                     <div className="text-white font-black text-lg">{duelChallenger.name}</div>
                                     <div className="text-amber-400 font-black text-2xl">{duelData.cWins} WIN</div>
                                     {duelData.cRoll !== null && (
                                         <div className="bg-white text-black w-12 h-12 flex items-center justify-center rounded-xl font-black text-2xl animate-bounce">
                                             {duelData.cRoll}
                                         </div>
                                     )}
                                 </div>

                                 <div className="text-white font-black text-4xl italic opacity-30">VS</div>

                                 {/* TARGET SIDE */}
                                 <div className={`flex flex-col items-center gap-2 transition-all ${isTargetTurn ? 'scale-110 opacity-100' : 'opacity-50'}`}>
                                     <div className={`p-2 rounded-full border-4 ${isTargetTurn ? 'border-amber-400 shadow-[0_0_20px_orange]' : 'border-slate-600'}`}>
                                         <PlayerAvatar charId={duelTarget.characterId} size="lg"/>
                                     </div>
                                     <div className="text-white font-black text-lg">{duelTarget.name}</div>
                                     <div className="text-amber-400 font-black text-2xl">{duelData.tWins} WIN</div>
                                     {duelData.tRoll !== null && (
                                         <div className="bg-white text-black w-12 h-12 flex items-center justify-center rounded-xl font-black text-2xl animate-bounce">
                                             {duelData.tRoll}
                                         </div>
                                     )}
                                 </div>
                             </div>

                             <div className="p-6 pt-0">
                                 {canControlDuel ? (
                                     <button 
                                         onClick={() => processDuelStep(isChallengerTurn ? 'challenger' : 'target')}
                                         className={`w-full py-6 rounded-2xl font-black text-2xl uppercase tracking-widest shadow-xl transition-all active:scale-95 ${isChallengerTurn ? 'bg-indigo-600 hover:bg-indigo-500 text-white' : 'bg-red-600 hover:bg-red-500 text-white'}`}
                                     >
                                         <Dices className="inline mb-1 mr-2"/>
                                         {isChallengerTurn ? `TIRA ${duelChallenger.name}!` : `TIRA ${duelTarget.name}!`}
                                     </button>
                                 ) : (
                                     <div className="w-full py-6 bg-slate-800 rounded-2xl text-slate-500 font-black text-center text-xl uppercase animate-pulse border-2 border-slate-700">
                                         IN ATTESA DI {isChallengerTurn ? duelChallenger.name : duelTarget.name}...
                                     </div>
                                 )}
                             </div>
                        </div>
                    </div>
                )}

                {(targetSelectionMode || bossTargetSelection) && canControlCurrent && !duelActive && (
                    <div className="fixed inset-0 z-[80] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-in fade-in">
                        <div className="max-w-md w-full bg-white rounded-2xl shadow-2xl border-4 border-indigo-500 overflow-hidden flex flex-col max-h-[80vh]">
                            <div className="p-4 bg-indigo-600 text-white text-center">
                                <h3 className="font-black text-xl uppercase flex items-center justify-center gap-2"><Target/> {bossTargetSelection ? "MARCHIA UN BERSAGLIO" : (targetSelectionMode === 'duel' ? "SCEGLI LO SFIDANTE" : "Seleziona Bersaglio")}</h3>
                                <p className="text-xs opacity-75">{bossTargetSelection ? "Il Boss sceglie la sua preda!" : (targetSelectionMode === 'duel' ? "Chi vuoi sfidare al lancio dei dadi?" : "Chi vuoi colpire?")}</p>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2">
                                {currentRoom.players
                                    .filter(p => p.uid !== currentPlayer.uid && !p.finished && !p.isDead && (!bossTargetSelection || p.uid !== currentRoom.hostId) && (currentRoom.gameMode !== 'sniper' || p.uid !== currentRoom.sniperUid))
                                    .sort((a,b) => b.position - a.position)
                                    .map(p => (
                                    <button key={p.uid} onClick={() => handleTargetClick(p.uid)} className="w-full flex items-center gap-4 p-3 rounded-xl border-2 border-slate-100 hover:border-red-500 hover:bg-red-50 transition-all group">
                                        <div className="relative">
                                            <PlayerAvatar charId={p.characterId} size="md" border={false}/>
                                            <div className="absolute -top-2 -right-2 bg-slate-800 text-white text-xs font-bold px-1.5 py-0.5 rounded-full border border-white">{p.position}</div>
                                        </div>
                                        <div className="flex-1 text-left">
                                            <div className="font-black text-slate-800 text-lg leading-none group-hover:text-red-600">{p.name}</div>
                                            {p.teamId !== undefined && <div className={`text-[10px] uppercase font-bold text-slate-400`}>Team {p.teamId+1}</div>}
                                            {p.uid === currentRoom.bossTargetUid && <div className="text-xs font-bold text-red-500">ATTUALE BERSAGLIO</div>}
                                        </div>
                                        {targetSelectionMode === 'duel' ? <SwordsIcon className="text-slate-300 group-hover:text-red-500"/> : <Pointer className="text-slate-300 group-hover:text-red-500 -rotate-90"/>}
                                    </button>
                                ))}
                            </div>
                            {!bossTargetSelection && <button onClick={() => {setTargetSelectionMode(null); setDecisionMode(false);}} className="p-4 bg-slate-200 font-bold hover:bg-slate-300 transition-colors">ANNULLA</button>}
                        </div>
                    </div>
                )}
                
                {/* ... (rest of the UI, including decision modal, cell info modal, error message, top bar, notification, menu, lobby, game board) ... */}
                
                {decisionMode && !targetSelectionMode && canControlCurrent && (
                    <div className="fixed inset-0 z-[70] flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-in fade-in">
                        <div className="max-w-md w-full flex flex-col items-center gap-4">
                            <div className="text-3xl font-black text-white drop-shadow-lg mb-4 flex items-center gap-2"><Gavel size={32} className="text-yellow-400"/> SCEGLI IL DESTINO</div>
                            <div className="grid grid-cols-1 gap-3 w-full">
                                {decisionOptions.map(opt => (
                                    <button key={opt.id} onClick={() => handleDecisionEffect(opt)} className="bg-white p-4 rounded-xl flex items-center gap-4 hover:scale-105 transition-all shadow-xl group">
                                        <div className="p-3 bg-indigo-100 rounded-full text-indigo-600 group-hover:bg-indigo-600 group-hover:text-white transition-colors">{opt.icon}</div>
                                        <div className="text-left">
                                            <div className="font-black text-lg text-slate-900">{opt.name}</div>
                                            <div className="text-xs text-slate-500 font-medium">{opt.desc}</div>
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>
                )}
                
                {selectedCellInfo && (
                    <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm">
                        <div className="bg-white rounded-2xl p-6 max-w-sm w-full shadow-2xl relative border-4 border-indigo-200">
                            <button onClick={()=>setSelectedCellInfo(null)} className="absolute top-2 right-2 p-1 rounded-full hover:bg-slate-100"><X size={20}/></button>
                            <div className="flex flex-col items-center text-center gap-3">
                                <div className="p-4 bg-indigo-50 rounded-full text-indigo-600 scale-125">{selectedCellInfo.icon}</div>
                                <h3 className="text-2xl font-black text-indigo-900">{selectedCellInfo.name}</h3>
                                <p className="text-lg text-slate-600 font-medium">{selectedCellInfo.desc}</p>
                            </div>
                        </div>
                    </div>
                )}

                {errorMsg && <div className="fixed top-0 left-0 w-full bg-red-600 text-white text-center p-2 z-[150] font-black uppercase tracking-tighter"><AlertCircle className="inline mr-2" /> {errorMsg}</div>}

                <div className="bg-indigo-900 text-white p-3 flex justify-between items-center shadow-lg z-50">
                    <div className="font-black text-xl flex items-center gap-2"><ArrowRight className="text-yellow-400"/> MULTIVERSE RUN</div>
                    
                    {currentRoom?.gameMode === 'relay' && isLeader && view === 'game' && (
                        <button onClick={toggleBotMode} className="bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg text-xs font-black border border-white/50 flex items-center gap-2 transition-colors">
                            <Bot size={16}/> 
                            <span>BOT: {currentRoom.teamBotModes?.[me.teamId] === 'manual' ? 'MANUALE' : 'AUTO'}</span>
                        </button>
                    )}

                    {currentRoom?.gameMode !== 'relay' && currentPlayer?.isBot && currentRoom?.hostId === user?.uid && view === 'game' && (
                         <div className="flex gap-2">
                             <button onClick={toggleBotSpeed} className={`bg-yellow-500 hover:bg-yellow-400 text-yellow-900 px-3 py-1.5 rounded-lg text-xs font-black border border-yellow-600 flex items-center gap-1 transition-colors ${botSpeed > 1 ? 'animate-pulse' : ''}`}>
                                <Zap size={14} className="fill-current"/> 
                                <span>{botSpeed > 2 ? 'MAX' : (botSpeed > 1 ? '2X' : '1X')}</span>
                             </button>
                             <button onClick={() => toggleGenericBotMode(currentPlayer.uid)} className="bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg text-xs font-black border border-white/50 flex items-center gap-2 transition-colors">
                                 <Bot size={16}/> 
                                 <span>BOT: {genericBotMode === 'manual' ? 'MANUALE' : 'AUTO'}</span>
                             </button>
                         </div>
                    )}

                    {/* FORCE TURN BUTTON (HOST ONLY) */}
                    {currentRoom?.hostId === user?.uid && view === 'game' && (
                        <button onClick={forceNextTurn} className="bg-red-500/20 hover:bg-red-500/40 text-red-200 border border-red-500/50 p-2 rounded-lg ml-2" title="Forza Prossimo Turno">
                            <SkipForward size={20}/>
                        </button>
                    )}

                    {currentRoom && view !== 'game' && <div className="font-mono bg-indigo-800 px-2 py-1 rounded text-xs flex items-center gap-2"><span>ROOM: {currentRoom.code}</span></div>}
                    {view !== 'menu' && <button onClick={() => { setView('menu'); setRoomCode(''); }}><LogOut size={20}/></button>}
                </div>

                <div className={`fixed top-16 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-2 rounded-full shadow-2xl transition-all duration-300 z-50 font-bold border border-slate-600 ${notif ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-10 pointer-events-none'}`}>{notif}</div>

                <div className="flex-1 flex overflow-hidden">
                    <div className="flex-1 overflow-y-auto p-4 flex flex-col items-center">
                        {view === 'menu' && (
                        <div className="max-w-md w-full mt-10 space-y-6">
                            <div className="text-center"><h1 className="text-4xl font-black text-indigo-900 mb-2">MULTIVERSE RUN</h1><p className="text-slate-500 font-bold uppercase tracking-widest text-xs">Arcade Edition</p></div>
                            <input type="text" placeholder="Nickname" className="w-full p-4 text-center text-xl font-black rounded-xl border-4 border-indigo-100 outline-none" value={nickname} onChange={e=>setNickname(e.target.value)} />
                            <div className="grid grid-cols-2 gap-2">
                                <button onClick={() => createRoom('classic')} disabled={!nickname} className="h-24 bg-green-500 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Flag className="mx-auto mb-1"/> CLASSICA</button>
                                <button onClick={() => createRoom('tournament')} disabled={!nickname} className="h-24 bg-yellow-500 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-yellow-200"><Trophy className="mx-auto mb-1"/> TORNEO</button>
                                <button onClick={() => createRoom('pressure')} disabled={!nickname} className="h-24 bg-red-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-red-400"><Gauge className="mx-auto mb-1"/> PRESSIONE</button>
                                <button onClick={() => createRoom('glitch')} disabled={!nickname} className="h-24 bg-purple-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-fuchsia-400"><Bug className="mx-auto mb-1"/> GLITCH</button>
                                <button onClick={() => createRoom('classic_punitive')} disabled={!nickname} className="h-24 bg-rose-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Swords className="mx-auto mb-1"/> PUNITIVA</button>
                                <button onClick={() => createRoom('elimination')} disabled={!nickname} className="h-24 bg-cyan-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Skull className="mx-auto mb-1"/> ELIMINAZIONE</button>
                                <button onClick={() => createRoom('battle_royale')} disabled={!nickname} className="h-24 bg-violet-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-yellow-400"><Crown className="mx-auto mb-1"/> BATTLE ROYALE</button>
                                <button onClick={() => createRoom('brawl')} disabled={!nickname} className="h-24 bg-stone-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-orange-500"><Grid3X3 className="mx-auto mb-1"/> BRAWL ARENA</button>
                                <button onClick={() => createRoom('infection')} disabled={!nickname} className="h-24 bg-lime-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Biohazard className="mx-auto mb-1"/> INFEZIONE</button>
                                <button onClick={() => createRoom('lava')} disabled={!nickname} className="h-24 bg-orange-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Flame className="mx-auto mb-1"/> LAVA</button>
                                <button onClick={() => createRoom('coin_collector')} disabled={!nickname} className="h-24 bg-yellow-400 rounded-xl text-yellow-900 font-black shadow-lg hover:scale-105 transition-all border-2 border-yellow-600"><Coins className="mx-auto mb-1"/> RACCOGLI MONETE</button>
                                <button onClick={() => createRoom('gem_hunt')} disabled={!nickname} className="h-24 bg-indigo-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Gem className="mx-auto mb-1"/> CACCIA ALLE GEMME</button>
                                <button onClick={() => createRoom('raid_boss')} disabled={!nickname} className="h-24 bg-red-900 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-red-500"><Crown className="mx-auto mb-1"/> RAID BOSS</button>
                                <button onClick={() => createRoom('black_hole')} disabled={!nickname} className="h-24 bg-black rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Disc className="mx-auto mb-1"/> BUCO NERO</button>
                                <button onClick={() => createRoom('tiles')} disabled={!nickname} className="h-24 bg-fuchsia-600 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Grid3X3 className="mx-auto mb-1"/> TILES</button>
                                <button onClick={() => createRoom('hunter')} disabled={!nickname} className="h-24 bg-slate-700 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-blue-400"><Siren className="mx-auto mb-1"/> GUARDIE/LADRI</button>
                                <button onClick={() => createRoom('sniper')} disabled={!nickname} className="h-24 bg-red-950 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all border-2 border-red-500"><Scope className="mx-auto mb-1"/> IL CECCHINO</button>
                                <button onClick={() => createRoom('reverse')} disabled={!nickname} className="h-24 bg-amber-500 rounded-xl text-white font-black shadow-lg hover:scale-105 transition-all"><Rewind className="mx-auto mb-1"/> REVERSE</button>
                            </div>
                            <button onClick={() => nickname && setView('relay_setup')} disabled={!nickname} className="w-full py-3 bg-blue-600 rounded-xl text-white font-black shadow-lg flex flex-col items-center"><Users size={20}/> STAFFETTA</button>
                            <div className="flex gap-2"><input id="codeIn" type="text" placeholder="CODICE" className="flex-1 p-3 rounded-xl border-2 font-black text-center uppercase"/><button onClick={() => joinRoom(document.getElementById('codeIn').value)} disabled={!nickname} className="px-6 bg-slate-800 text-white font-black rounded-xl uppercase text-xs">Entra</button></div>
                        </div>
                        )}
                        
                        {/* ... (relay_setup, lobby logic preserved) ... */}
                        
                        {view === 'relay_setup' && (
                            <div className="max-w-md w-full mt-10 space-y-6 bg-white p-6 rounded-2xl shadow-xl border-4 border-indigo-100">
                                <h2 className="text-2xl font-black text-center text-indigo-900">CONFIGURA STAFFETTA</h2>
                                <div><label className="block font-black text-slate-400 mb-2 uppercase text-xs">Numero Team</label><div className="flex gap-2">{[2,3,4].map(n => (<button key={n} onClick={() => setRelayConfig({...relayConfig, teams: n})} className={`flex-1 py-3 rounded-lg font-black ${relayConfig.teams === n ? 'bg-indigo-600 text-white' : 'bg-slate-100'}`}>{n}</button>))}</div></div>
                                <div><label className="block font-black text-slate-400 mb-2 uppercase text-xs">Corridori per Team</label><div className="flex gap-2">{[2,3,4].map(n => (<button key={n} onClick={() => setRelayConfig({...relayConfig, size: n})} className={`flex-1 py-3 rounded-lg font-black ${relayConfig.size === n ? 'bg-indigo-600 text-white' : 'bg-slate-100'}`}>{n}</button>))}</div></div>
                                <button onClick={() => createRoom('relay')} className="w-full py-4 bg-green-500 text-white font-black text-xl rounded-xl shadow-lg">CREA</button>
                            </div>
                        )}

                        {view === 'lobby' && currentRoom && (
                        <div className="w-full max-w-6xl space-y-6">
                            <div className="bg-white p-6 rounded-2xl shadow-sm border flex justify-between items-center gap-4">
                                <div><h2 className="text-2xl font-black text-indigo-900 uppercase">{currentRoom.gameMode.replace('_', ' ')}</h2></div>
                                {currentRoom.hostId === user.uid && <div className="flex gap-2">
                                    <button onClick={addBot} className="bg-slate-200 px-4 py-2 rounded-lg font-black text-xs uppercase hover:bg-slate-300">Add Bot</button>
                                    {currentRoom.gameMode === 'battle_royale' && <button onClick={fillLobbyBots} className="bg-violet-200 text-violet-800 px-4 py-2 rounded-lg font-black text-xs uppercase hover:bg-violet-300">RIEMPI 32</button>}
                                    {currentRoom.gameMode === 'tournament' && <button onClick={fillLobbyBots} className="bg-yellow-200 text-yellow-800 px-4 py-2 rounded-lg font-black text-xs uppercase hover:bg-yellow-300">RIEMPI 8</button>}
                                    {currentRoom.gameMode === 'pressure' && <button onClick={fillLobbyBots} className="bg-red-200 text-red-800 px-4 py-2 rounded-lg font-black text-xs uppercase hover:bg-red-300">RIEMPI 10</button>}
                                    <button onClick={startGame} className="bg-green-500 text-white px-8 py-2 rounded-lg font-black shadow-lg">START</button>
                                </div>}
                            </div>
                            
                            {/* ... (Tournament, Battle Royale, Tiles config panels preserved) ... */}
                            {currentRoom.gameMode === 'tournament' && currentRoom.hostId === user.uid && (
                                <div className="bg-white p-6 rounded-2xl shadow-md border-t-8 border-yellow-500 animate-in slide-in-from-top-4">
                                    <h3 className="font-black text-lg text-yellow-800 mb-4 flex items-center gap-2"><Trophy/> CONFIGURAZIONE TORNEO</h3>
                                    <div className="space-y-2">
                                        <div className="text-xs font-bold text-slate-400 uppercase tracking-widest">Numero di Round</div>
                                        <div className="flex gap-2">
                                            {[2,3,4].map(n => (
                                                <button key={n} onClick={() => setTournamentRounds(n)} className={`flex-1 py-3 rounded-lg font-black ${tournamentRounds === n ? 'bg-yellow-500 text-white' : 'bg-slate-100 text-slate-600'}`}>
                                                    {n} ROUND
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {currentRoom.gameMode === 'battle_royale' && currentRoom.hostId === user.uid && (
                                <div className="bg-white p-6 rounded-2xl shadow-md border-t-8 border-violet-500 animate-in slide-in-from-top-4">
                                    <h3 className="font-black text-lg text-violet-800 mb-2 flex items-center gap-2"><List/> CONFIGURAZIONE ROUND</h3>
                                    <p className="text-xs text-slate-500 mb-2">Inserisci il numero di qualificati per ogni round, separati da virgola. Esempio: 16, 8, 4, 1</p>
                                    <input 
                                        type="text" 
                                        value={brConfigInput} 
                                        onChange={(e) => updateBrConfig(e.target.value)} 
                                        className="w-full p-3 border-2 border-violet-200 rounded-xl font-mono text-lg font-bold text-violet-900 focus:outline-none focus:border-violet-500"
                                        placeholder="Esempio: 16, 8, 4, 2, 1"
                                    />
                                    <div className="mt-2 text-xs font-bold text-violet-400 uppercase">
                                        Round attuali: {brConfigInput.split(',').filter(n=>n.trim()).length}
                                    </div>
                                </div>
                            )}

                            {currentRoom.gameMode === 'tiles' && (
                                <div className="bg-white p-6 rounded-2xl shadow-md border-t-8 border-fuchsia-500 animate-in slide-in-from-top-4">
                                    <h3 className="font-black text-lg text-fuchsia-800 mb-4 flex items-center gap-2"><Palette/> CONFIGURAZIONE TILES</h3>
                                    <div className="space-y-6">
                                        <div className="space-y-2">
                                            <div className="text-xs font-bold text-slate-400 uppercase tracking-widest">Il tuo Colore</div>
                                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                                                {PAINT_COLORS.map(c => (
                                                    <button 
                                                        key={c} 
                                                        onClick={() => updatePaintColor(c)}
                                                        className={`w-10 h-10 rounded-full flex-shrink-0 transition-all ${selectedPaintColor === c ? 'scale-125 ring-4 ring-offset-2 ring-slate-400' : 'hover:scale-110'}`}
                                                        style={{backgroundColor: c}}
                                                    />
                                                ))}
                                            </div>
                                        </div>
                                        {currentRoom.hostId === user.uid && (
                                            <div className="space-y-2">
                                                <div className="flex justify-between items-center text-xs font-bold text-slate-400 uppercase tracking-widest">
                                                    <span><Timer size={14} className="inline mr-1"/>Durata Partita</span>
                                                    <span className="text-fuchsia-600 text-lg">{turnLimit} Turni</span>
                                                </div>
                                                <input 
                                                    type="range" 
                                                    min="5" 
                                                    max="30" 
                                                    value={turnLimit} 
                                                    onChange={(e) => setTurnLimit(Number(e.target.value))}
                                                    className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-fuchsia-600"
                                                />
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {/* ... (Player List panel preserved) ... */}
                            {currentRoom.gameMode === 'relay' ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    {Array.from({ length: currentRoom.teamConfig.teams }).map((_, teamIdx) => {
                                        const teamPlayers = currentRoom.players.filter(p => p.teamId === teamIdx);
                                        const teamHumanPlayers = teamPlayers.filter(p => !p.isBot);
                                        const isMyTeam = currentRoom.players.find(p => p.uid === user.uid)?.teamId === teamIdx;
                                        // Team Leader is first human in the team list
                                        const teamLeader = teamHumanPlayers.length > 0 ? teamHumanPlayers[0].uid : null;
                                        const amILeader = teamLeader === user.uid;
                                        
                                        return (
                                            <div key={teamIdx} className={`bg-white rounded-2xl shadow-md overflow-hidden border-t-8 ${TEAM_COLORS[teamIdx].border}`}>
                                                <div className={`p-3 ${TEAM_COLORS[teamIdx].light} flex justify-between items-center`}>
                                                    <h3 className={`font-black uppercase ${TEAM_COLORS[teamIdx].text}`}>TEAM {teamIdx + 1}</h3>
                                                    {amILeader && (
                                                        <button onClick={() => toggleBotModeLobby(teamIdx)} className="flex items-center gap-1 bg-white/50 hover:bg-white px-2 py-1 rounded text-[10px] font-bold border border-black/5 transition-colors">
                                                            <Bot size={12}/> {currentRoom.teamBotModes?.[teamIdx] === 'manual' ? 'MANUALE' : 'AUTO'}
                                                        </button>
                                                    )}
                                                </div>
                                                <div className="p-3 space-y-2 max-h-60 overflow-y-auto">
                                                    {teamPlayers.map(p => (
                                                        <div key={p.uid} className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg border">
                                                            <PlayerAvatar charId={p.characterId} size="sm"/>
                                                            <div className="flex-1 min-w-0">
                                                                <div className="font-bold text-sm truncate flex items-center gap-2">
                                                                    {p.name} 
                                                                    {p.isBot && <span className="text-[10px] bg-slate-200 px-1 rounded text-slate-500">BOT</span>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                    {teamPlayers.length === 0 && <div className="text-center text-xs text-slate-400 py-4 italic">Nessun giocatore</div>}
                                                </div>
                                                {!isMyTeam && (
                                                    <div className="p-2 border-t bg-slate-50">
                                                        <button onClick={() => switchTeam(teamIdx)} className="w-full py-2 bg-white border-2 hover:bg-slate-100 rounded-lg text-xs font-black uppercase flex items-center justify-center gap-2 transition-colors">
                                                            <Move size={14}/> Unisciti
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            ) : (
                                <div className="flex flex-col md:flex-row gap-4">
                                    <div className="w-full md:w-1/3 bg-white p-4 rounded-2xl shadow-sm border h-fit max-h-96 overflow-y-auto">
                                         <h3 className="font-black text-indigo-900 mb-2 flex items-center gap-2 text-sm uppercase"><Users size={16}/> Giocatori ({currentRoom.players.length})</h3>
                                         <div className="space-y-2">
                                            {currentRoom.players.map(p => (
                                                <div key={p.uid} className="flex items-center gap-2 p-2 bg-slate-50 rounded-lg border">
                                                    <PlayerAvatar charId={p.characterId} size="sm"/>
                                                    <div className="flex-1 min-w-0">
                                                        <div className="font-bold text-sm truncate flex items-center gap-2">
                                                            {p.name} 
                                                            {p.isBot && <span className="text-[10px] bg-slate-200 px-1 rounded text-slate-500">BOT</span>}
                                                        </div>
                                                        <div className="text-[10px] text-slate-400 uppercase font-bold">{ROSTER[p.characterId].name}</div>
                                                    </div>
                                                    {p.uid === currentRoom.hostId && <Crown size={14} className="text-yellow-500"/>}
                                                    {currentRoom.gameMode === 'tiles' && p.paintColor && (
                                                        <div className="w-4 h-4 rounded-full border border-slate-300 shadow-sm" style={{backgroundColor: p.paintColor}}></div>
                                                    )}
                                                    {(currentRoom.gameMode === 'lava' || currentRoom.gameMode === 'glitch' || currentRoom.gameMode === 'brawl') && p.lives !== undefined && (
                                                        <div className="flex items-center gap-0.5 text-red-500 font-black text-xs">
                                                            <Heart size={12} className="fill-current"/> x {p.lives}
                                                        </div>
                                                    )}
                                                    {currentRoom.gameMode === 'sniper' && p.lives !== undefined && p.uid !== currentRoom.sniperUid && (
                                                        <div className="flex items-center gap-0.5 text-red-500 font-black text-xs">
                                                            <Heart size={12} className="fill-current"/> x {p.lives}
                                                        </div>
                                                    )}
                                                    {currentRoom.gameMode === 'raid_boss' && (
                                                        <div className="flex items-center gap-0.5 font-black text-xs">
                                                            {p.uid === currentRoom.hostId ? <span className="text-red-700 bg-red-100 px-1 rounded">BOSS</span> : <span className="text-blue-700 bg-blue-100 px-1 rounded flex items-center gap-1"><Heart size={10} className="fill-current"/> {p.lives}</span>}
                                                        </div>
                                                    )}
                                                    {currentRoom.gameMode === 'hunter' && (
                                                        <div className="flex items-center gap-0.5 font-black text-xs">
                                                            {p.uid === currentRoom.guardUid ? 
                                                                <span className="text-blue-700 bg-blue-100 px-1 rounded flex items-center gap-1 border border-blue-200"><Shield size={10} className="fill-current"/> GUARDIA</span> 
                                                                : 
                                                                (currentRoom.hostId === user.uid ? 
                                                                    <button onClick={() => setGuard(p.uid)} className="text-slate-400 hover:text-blue-500 bg-slate-100 hover:bg-blue-50 px-2 py-0.5 rounded border flex items-center gap-1 transition-colors" title="Assegna Guardia"><Shield size={10}/> Rendi Guardia</button> 
                                                                    : <span className="text-slate-500 bg-slate-100 px-1 rounded flex items-center gap-1"><Footprints size={10}/> LADRO</span>
                                                                )
                                                            }
                                                        </div>
                                                    )}
                                                    {currentRoom.gameMode === 'sniper' && p.uid === currentRoom.sniperUid && (
                                                        <span className="text-red-700 bg-red-100 px-1 rounded flex items-center gap-1 border border-red-200"><Scope size={10} /> CECCHINO</span> 
                                                    )}
                                                </div>
                                            ))}
                                         </div>
                                    </div>
                                    
                                    <div className="flex-1">
                                        <div className="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-2">
                                            {ROSTER.map(c => {
                                                const taken = currentRoom.players.some(p => p.characterId === c.id);
                                                const mine = currentRoom.players.find(p => p.uid === user.uid)?.characterId === c.id;
                                                return (<button key={c.id} onClick={() => selectChar(c.id)} disabled={taken && !mine} className={`relative aspect-[3/4] rounded-xl overflow-hidden transition-all bg-slate-100 ${mine ? 'ring-4 ring-indigo-500 scale-105 z-10' : ''} ${taken && !mine ? 'grayscale opacity-50' : ''}`}><img src={c.img} className="w-full h-full object-cover"/><div className={`absolute bottom-0 w-full text-[8px] p-1 font-black text-white ${c.dice.color}`}>{c.dice.name}</div></button>)
                                            })}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                        )}
                        
                        {/* ... (Game View: Top bar, Grid, Bottom Controls, Ranking Sidebar) ... */}
                        {view === 'game' && currentRoom && currentPlayer && (
                        <div className="w-full max-w-5xl flex flex-col gap-4">
                            <div className="flex items-center justify-between bg-white p-3 rounded-xl shadow-sm border sticky top-0 z-40">
                                <div className="flex items-center gap-3">
                                    <div className="text-center"><div className="text-[10px] text-slate-400 font-black uppercase tracking-widest">Turno</div><div className="font-black text-indigo-900 leading-none">{currentPlayer.name}</div></div>
                                    <PlayerAvatar charId={currentPlayer.characterId}/>
                                    {/* ... (Status badges preserved) ... */}
                                    {(currentRoom.gameMode === 'lava' || currentRoom.gameMode === 'glitch' || currentRoom.gameMode === 'brawl') && currentPlayer.lives !== undefined && (
                                         <div className="flex items-center gap-1 bg-red-100 text-red-600 px-2 py-1 rounded-lg border border-red-200">
                                            <Heart size={16} className="fill-current"/> <span className="font-black text-lg">{currentPlayer.lives}</span>
                                         </div>
                                    )}
                                    {currentRoom.gameMode === 'coin_collector' && (
                                         <div className="flex items-center gap-2 bg-yellow-50 text-yellow-700 px-3 py-1 rounded-lg border border-yellow-200 shadow-sm animate-pulse">
                                            <Coins size={20} className="fill-yellow-400 text-yellow-600"/> 
                                            <span className="font-black text-xl">{currentPlayer.score || 0}</span>
                                            <span className="text-xs font-bold text-yellow-600/50 uppercase">/ {currentRoom.maxScore}</span>
                                         </div>
                                    )}
                                    {currentRoom.gameMode === 'tournament' && (
                                        <div className="flex items-center gap-1 bg-yellow-100 text-yellow-800 px-3 py-1 rounded-lg border border-yellow-200 font-black text-xs uppercase">
                                            PUNTI: {currentPlayer.score || 0}
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'pressure' && (
                                        <div className="flex items-center gap-1 bg-red-100 text-red-800 px-3 py-1 rounded-lg border border-red-200 font-black text-xs uppercase">
                                            <RefreshCcw size={14}/> GIRI: {currentPlayer.laps || 0}
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'battle_royale' && (
                                        <div className="flex items-center gap-1 bg-violet-100 text-violet-700 px-3 py-1 rounded-lg border border-violet-200 font-black text-xs uppercase">
                                            ROUND {currentRoom.battleRoundIndex + 1} • QUALIFY: {currentRoom.players.filter(p=>p.finished).length} / {currentRoom.qualifyLimit}
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'glitch' && currentRoom.activeGlitch && (
                                        <div className="flex items-center gap-1 bg-purple-900 text-green-400 px-3 py-1 rounded-lg border border-green-500 font-black text-xs uppercase shadow-[0_0_10px_#0f0] animate-pulse">
                                            <Bug size={14}/> {currentRoom.activeGlitch.toUpperCase()}
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'tiles' && currentPlayer.paintColor && (
                                         <div className="flex items-center gap-1 px-2 py-1 rounded-lg border bg-slate-50" style={{borderColor: currentPlayer.paintColor}}>
                                            <div className="w-4 h-4 rounded-full" style={{backgroundColor: currentPlayer.paintColor}}></div>
                                            <span className="font-black text-xs">COLORE</span>
                                         </div>
                                    )}
                                    {currentRoom.gameMode === 'raid_boss' && (
                                        <div className="flex items-center gap-2">
                                            {currentPlayer.uid === currentRoom.hostId ? 
                                                <div className="bg-red-900 text-white px-3 py-1 rounded-lg font-black flex items-center gap-1"><Crown size={14}/> BOSS ({currentRoom.bossHp} HP)</div> 
                                                : 
                                                <div className="bg-blue-100 text-blue-700 px-3 py-1 rounded-lg font-black flex items-center gap-1"><Heart size={14} className="fill-current"/> {currentPlayer.lives} VITE</div>
                                            }
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'hunter' && (
                                        <div className="flex items-center gap-2">
                                            {currentPlayer.uid === currentRoom.guardUid ? 
                                                <div className="bg-blue-900 text-white px-3 py-1 rounded-lg font-black flex items-center gap-1"><Shield size={14}/> GUARDIA</div> 
                                                : 
                                                <div className="bg-slate-100 text-slate-700 px-3 py-1 rounded-lg font-black flex items-center gap-1"><Footprints size={14}/> LADRO</div>
                                            }
                                        </div>
                                    )}
                                    {currentRoom.gameMode === 'sniper' && (
                                        <div className="flex items-center gap-2">
                                            {currentPlayer.uid === currentRoom.sniperUid ? 
                                                <div className="bg-red-950 text-white px-3 py-1 rounded-lg font-black flex items-center gap-1"><Scope size={14}/> CECCHINO</div> 
                                                : 
                                                <div className="bg-red-50 text-red-600 px-3 py-1 rounded-lg font-black flex items-center gap-1"><Heart size={14} className="fill-current"/> {currentPlayer.lives} VITE</div>
                                            }
                                        </div>
                                    )}
                                </div>
                                <div className="text-right">
                                    <div className="text-[10px] text-slate-400 font-black uppercase tracking-widest">{currentRoom.gameMode.toUpperCase().replace('_', ' ')}</div>
                                    <div className="font-black text-indigo-900 leading-none">ROUND {currentRoom.round} {currentRoom.gameMode === 'tiles' && `/ ${currentRoom.maxRounds}`} {currentRoom.gameMode === 'tournament' && `/ ${currentRoom.tournamentTotalRounds}`} {currentRoom.gameMode === 'pressure' && ((currentRoom.round % 3 === 0) ? <span className="text-red-600 animate-pulse"> • ELIMINAZIONE!</span> : <span className="text-slate-400"> • Next Kill: {Math.ceil(currentRoom.round/3)*3}</span>)}</div>
                                </div>
                            </div>

                            <div className={`gap-1.5 p-2 bg-slate-200/50 rounded-xl grid ${currentRoom.gameMode === 'brawl' ? 'grid-cols-8 max-w-2xl mx-auto' : (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' ? 'grid-cols-11' : 'grid-cols-5 md:grid-cols-8 lg:grid-cols-10')} ${currentRoom.activeGlitch === 'earthquake' ? 'animate-bounce' : ''} ${currentRoom.activeGlitch === 'darkness' ? 'grayscale brightness-50 contrast-150' : ''}`}>
                                {Array.from({ length: (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' ? 121 : (currentRoom.gameMode === 'battle_royale' ? 40 : (currentRoom.gameMode === 'brawl' ? 64 : (currentRoom.gameMode === 'elimination' ? 34 : (currentRoom.gameMode === 'gem_hunt' ? 50 : (currentRoom.gameMode === 'hunter' ? 80 : 60)))))) + (currentRoom.gameMode === 'brawl' ? 0 : 1) }).map((_, i) => (
                                    <BoardCell 
                                        key={i} 
                                        num={i} 
                                        players={currentRoom.players.filter(p => p.position === i && !p.isDead)} 
                                        special={(currentRoom.gameMode === 'elimination' ? (currentRoom.customSpecials?.[i] || ELIM_MAP.specials[i]) : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP.specials[i] : (currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl' ? null : (currentRoom.gameMode === 'reverse' ? REVERSE_MAP.specials[i] : (currentRoom.gameMode === 'battle_royale' ? BATTLE_ROYALE_MAP.specials[i] : (currentRoom.gameMode === 'hunter' ? HUNTER_MAP.specials[i] : CLASSIC_MAP.specials[i]))))))} 
                                        isElimination={currentRoom.gameMode === 'elimination'} 
                                        isBattleRoyale={currentRoom.gameMode === 'battle_royale'}
                                        isTournament={currentRoom.gameMode === 'tournament'} 
                                        isPendingTarget={canControlCurrent && currentPlayer.pendingTarget === i} 
                                        isValidMoveTarget={(currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl') && canControlCurrent && currentPlayer.remainingMoves > 0 && getManhattanDistance(currentPlayer.position, i, currentRoom.gameMode === 'brawl' ? 8 : 11) === 1 && (!currentRoom.voidTiles || !currentRoom.voidTiles.includes(i))}
                                        onCellClick={isSniperTurn ? () => handleSniperTileClick(i) : (targetSelectionMode ? () => {} : ((currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl') && canControlCurrent && currentPlayer.remainingMoves > 0 ? () => executeTileMove(user.uid, i) : () => executeMove(user.uid, i)))}
                                        onInfoClick={(s) => setSelectedCellInfo(s)} 
                                        gems={currentRoom.gemLocations} 
                                        coinLocations={currentRoom.coinLocations}
                                        infected={currentRoom.infectedNPC} 
                                        isTargetSelection={isSniperTurn} 
                                        lavaTiles={currentRoom.lavaTiles} 
                                        blackHolePos={currentRoom.blackHolePos} 
                                        bossTargetUid={currentRoom.bossTargetUid}
                                        tileOwnerColor={currentRoom.tileOwners?.[i]}
                                        isTilesMode={currentRoom.gameMode === 'tiles'}
                                        isReverse={currentRoom.gameMode === 'reverse'}
                                        sniperTargets={isSniperTurn ? sniperSelection : currentRoom.sniperTargets}
                                        activeGlitch={currentRoom.activeGlitch}
                                        currentUserId={user.uid}
                                        voidTiles={currentRoom.voidTiles}
                                        warningTiles={currentRoom.warningTiles}
                                    />
                                ))}
                            </div>

                            <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-40 w-full max-w-sm px-4">
                                {currentRoom.status === 'finished' ? (
                                    <div className="bg-indigo-900 text-white p-6 rounded-2xl shadow-2xl text-center border-4 border-yellow-400 animate-bounce-slow"><Trophy size={48} className="mx-auto text-yellow-400 mb-2"/><h2 className="text-3xl font-black uppercase">Vittoria!</h2><p className="text-xl font-bold opacity-90">{currentRoom.winner}</p><button onClick={() => { setView('menu'); setRoomCode(''); }} className="mt-4 bg-white text-indigo-900 px-6 py-2 rounded-full font-black uppercase text-xs">Menu</button></div>
                                ) : (
                                    <div className="space-y-2">
                                        {/* SNIPER UI */}
                                        {isSniperTurn && (
                                            <div className="bg-red-950 p-4 rounded-2xl shadow-2xl border-4 border-red-500 animate-in slide-in-from-bottom-4">
                                                <h3 className="text-center font-black text-white text-xl uppercase mb-2">SELEZIONA 3 BERSAGLI</h3>
                                                <div className="flex justify-center gap-2 mb-4">
                                                    {[0,1,2].map(i => (
                                                        <div key={i} className={`w-10 h-10 rounded-lg border-2 flex items-center justify-center font-black ${sniperSelection[i] !== undefined ? 'bg-red-500 border-red-400 text-white' : 'bg-red-900/50 border-red-800 text-red-700'}`}>
                                                            {sniperSelection[i] !== undefined ? sniperSelection[i] : '?'}
                                                        </div>
                                                    ))}
                                                </div>
                                                <button onClick={confirmSniperShot} disabled={sniperSelection.length === 0} className="w-full py-3 bg-red-600 hover:bg-red-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-black rounded-xl uppercase flex items-center justify-center gap-2 transition-all active:scale-95">
                                                    <Scope className={sniperSelection.length > 0 ? "animate-pulse" : ""}/> FUOCO!
                                                </button>
                                            </div>
                                        )}

                                        {/* Normal Dice UI */}
                                        {!isSniperTurn && !duelActive && canControlCurrent && lastRoll !== null && !isRolling && !directionChoice && !decisionMode && (!currentPlayer.remainingMoves || currentPlayer.remainingMoves <= 0) && (
                                            <div className="bg-white/90 backdrop-blur-sm border-2 border-indigo-500 text-indigo-900 rounded-xl p-2 text-center shadow-lg animate-in slide-in-from-bottom-2">
                                                <div className="text-[10px] font-black uppercase tracking-widest opacity-60">Hai fatto</div>
                                                <div className="text-3xl font-black leading-none">
                                                    {lastRoll}
                                                    {currentRoom.gameMode === 'hunter' && currentPlayer.uid === currentRoom.guardUid && <span className="text-xs ml-2 text-blue-500 font-bold">(+2 BUFF)</span>}
                                                </div>
                                            </div>
                                        )}

                                        {(currentRoom.gameMode === 'tiles' || currentRoom.gameMode === 'coin_collector' || currentRoom.gameMode === 'brawl') && currentPlayer.remainingMoves > 0 && canControlCurrent && (
                                            <div className="bg-white p-4 rounded-2xl shadow-2xl border-4 border-fuchsia-500 animate-bounce flex flex-col items-center gap-2">
                                                <h3 className="font-black text-fuchsia-900 uppercase">HAI {currentPlayer.remainingMoves} PASSI!</h3>
                                                <div className="text-xs font-bold text-center">
                                                    {currentRoom.gameMode === 'coin_collector' ? "Raggiungi le monete!" : (currentRoom.gameMode === 'brawl' ? "Muoviti per sopravvivere! Spingi i nemici!" : "Tocca una casella vicina per colorare!")}
                                                </div>
                                            </div>
                                        )}
                                        
                                        {directionChoice && canControlCurrent && (
                                            <div className="bg-white p-4 rounded-2xl shadow-2xl border-4 border-indigo-500 animate-bounce flex flex-col items-center gap-4"><h3 className="font-black text-indigo-900 uppercase">Scegli Direzione: {directionChoice.val}</h3><div className="flex gap-4 w-full"><button onClick={() => confirmGemMove(-1)} className="flex-1 bg-red-500 text-white py-3 rounded-xl font-black uppercase flex flex-col items-center"><ArrowLeft/> Indietro</button><button onClick={() => confirmGemMove(1)} className="flex-1 bg-green-500 text-white py-3 rounded-xl font-black uppercase flex flex-col items-center"><ArrowRight/> Avanti</button></div></div>
                                        )}
                                        {!directionChoice && !decisionMode && !bossTargetSelection && !targetSelectionMode && !isSniperTurn && !duelActive && (!currentPlayer.remainingMoves || currentPlayer.remainingMoves <= 0) && (
                                            canControlCurrent ? (
                                                <button onClick={handleRoll} disabled={isRolling || isMoving || currentPlayer.pendingTarget !== null} className={`w-full py-4 rounded-2xl font-black text-2xl shadow-xl transition-all flex items-center justify-center gap-3 border-b-8 active:translate-y-2 active:border-b-0 ${isRolling || isMoving ? 'bg-slate-300 border-slate-400' : 'bg-orange-500 text-white border-orange-700'} ${currentRoom.activeGlitch ? 'glitch-text' : ''}`}>{isRolling ? <Dice5 className="animate-spin"/> : <Dice5/>} <span>{isRolling ? "..." : (currentPlayer.pendingTarget !== null ? "CLICCA LA CASELLA!" : (currentPlayer.activeCurse ? "MALEDETTO!" : "TIRA DADO"))}</span></button>
                                            ) : (
                                                currentPlayer.isBot ? (
                                                    <div className="w-full py-4 rounded-2xl font-black text-xl bg-slate-100 text-slate-400 flex items-center justify-center gap-2 animate-pulse border-2 border-slate-200">
                                                        <Bot size={24}/> <span>IL BOT STA GIOCANDO...</span>
                                                    </div>
                                                ) : (
                                                    <div className="w-full py-4 rounded-2xl font-black text-xl bg-slate-100 text-slate-400 flex items-center justify-center gap-2 border-2 border-slate-200">
                                                        <Dice5 size={24}/> <span>TURNO DI {currentPlayer.name}</span>
                                                    </div>
                                                )
                                            )
                                        )}
                                        {canControlCurrent && currentPlayer.pendingTarget === null && !directionChoice && !decisionMode && !targetSelectionMode && !isSniperTurn && !duelActive && !currentPlayer.activeCurse && !bossTargetSelection && (!currentPlayer.remainingMoves || currentPlayer.remainingMoves <= 0) && (
                                            <div className="bg-white p-3 rounded-xl shadow-lg border-2 flex flex-col gap-2 animate-in slide-in-from-bottom-4 fade-in duration-500">
                                                <div className="flex justify-between items-end">
                                                     <div className="text-[10px] font-black text-slate-400 uppercase mb-1">{currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? "DADO BOSS" : (currentRoom.gameMode === 'hunter' && currentPlayer.uid === currentRoom.guardUid ? "DADO GUARDIA" : "Probabilità")}</div>
                                                </div>
                                                <div className="flex justify-between gap-1">
                                                    {(currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? BOSS_DICE_VALS : ROSTER[currentPlayer.characterId].dice.vals).map((v, i) => (
                                                        <div key={i} className={`flex-1 aspect-square flex items-center justify-center rounded-lg border-2 font-black text-sm transition-all ${currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId ? 'text-red-500 bg-red-50 border-red-200' : (useSpecialDie ? `${ROSTER[currentPlayer.characterId].dice.text} border-current bg-white shadow-sm` : 'text-slate-300 border-slate-100 bg-slate-50')}`}>
                                                            {v}
                                                        </div>
                                                    ))}
                                                </div>
                                                {!(currentRoom.gameMode === 'raid_boss' && currentPlayer.uid === currentRoom.hostId) && !(currentRoom.gameMode === 'hunter' && currentPlayer.uid === currentRoom.guardUid) && (
                                                <>
                                                    <div className="h-px bg-slate-100 my-1"></div>
                                                    <div className="flex justify-between items-center">
                                                        <div className="flex flex-col">
                                                            <span className="text-[10px] font-black text-slate-400 uppercase leading-none">Usa Dado Speciale</span>
                                                            <span className={`font-black ${ROSTER[currentPlayer.characterId].dice.text}`}>{ROSTER[currentPlayer.characterId].dice.name}</span>
                                                        </div>
                                                        <button onClick={() => setUseSpecialDie(!useSpecialDie)} className={`px-4 py-2 rounded-xl font-black text-xs transition-all ${useSpecialDie ? 'bg-indigo-900 text-white shadow-lg scale-105' : 'bg-slate-100 text-slate-400'}`}>{useSpecialDie ? 'ON' : 'OFF'}</button>
                                                    </div>
                                                </>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                        )}
                    </div>

                    {view === 'game' && currentRoom && (
                        <div className="hidden lg:flex flex-col w-80 bg-indigo-950 text-white border-l-4 border-white/10 overflow-y-auto p-4 space-y-3">
                            <h3 className="font-black text-lg border-b border-white/10 pb-2 flex items-center gap-2"><Trophy size={20} className="text-yellow-400"/> CLASSIFICA</h3>
                            {[...currentRoom.players].sort((a,b) => {
                                if (currentRoom.gameMode === 'tournament') return (b.score || 0) - (a.score || 0); // Tournament Sort by Score
                                if (currentRoom.gameMode === 'pressure') {
                                    if (a.isDead && !b.isDead) return 1;
                                    if (!a.isDead && b.isDead) return -1;
                                    // Sort by Laps descending, then Position descending
                                    if ((a.laps || 0) !== (b.laps || 0)) return (b.laps || 0) - (a.laps || 0);
                                    return b.position - a.position;
                                }
                                if (a.isDead && !b.isDead) return 1; 
                                if (!a.isDead && b.isDead) return -1;
                                if (currentRoom.gameMode === 'tiles') {
                                    const countA = Object.values(currentRoom.tileOwners || {}).filter(c => c === a.paintColor).length;
                                    const countB = Object.values(currentRoom.tileOwners || {}).filter(c => c === b.paintColor).length;
                                    return countB - countA;
                                }
                                if (currentRoom.gameMode === 'coin_collector') return (b.score || 0) - (a.score || 0);
                                if (a.finished && !b.finished) return -1;
                                if (!a.finished && b.finished) return 1;
                                if (a.finished && b.finished) return (a.rank || 0) - (b.rank || 0);
                                if (currentRoom.gameMode === 'gem_hunt') return (b.collectedGems?.length||0) - (a.collectedGems?.length||0);
                                if (currentRoom.gameMode === 'reverse') return a.position - b.position; 
                                return b.position - a.position;
                            }).map((p, i) => {
                                const tileCount = currentRoom.gameMode === 'tiles' ? Object.values(currentRoom.tileOwners || {}).filter(c => c === p.paintColor).length : 0;
                                return (
                                <div key={p.id} onClick={() => targetSelectionMode && handleTargetClick(p.uid)} className={`p-3 rounded-xl border-2 flex items-center gap-3 transition-all ${p.uid === user.uid ? 'bg-white/10 border-indigo-400' : 'bg-black/20 border-transparent'} ${targetSelectionMode ? 'cursor-pointer hover:border-red-500 hover:bg-white/5' : ''}`}>
                                    <div className="font-black text-white/40 w-6">{p.isDead ? '💀' : (p.finished ? '🏁' : `${i+1}°`)}</div>
                                    <PlayerAvatar charId={p.characterId} size="sm"/>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-black text-sm truncate">{p.name}</div>
                                        <div className="text-[10px] font-bold text-white/50 uppercase">
                                            {currentRoom.gameMode === 'tiles' ? `Tiles: ${tileCount}` : (currentRoom.gameMode === 'coin_collector' ? `${p.score || 0} Punti` : (p.isDead ? 'Eliminato' : (p.finished ? 'Qualificato' : `Casella ${p.position}`)))} 
                                            {p.activeCurse && "• Maledetto"}
                                            {p.extraDice && "• DADI++"}
                                            {currentRoom.gameMode === 'gem_hunt' && ` • Gemme: ${p.collectedGems?.length || 0}/5`}
                                            {currentRoom.gameMode === 'lava' && ` • Vite: ${p.lives}`}
                                            {currentRoom.gameMode === 'glitch' && ` • Vite: ${p.lives}`}
                                            {currentRoom.gameMode === 'brawl' && ` • Vite: ${p.lives}`}
                                            {currentRoom.gameMode === 'tournament' && ` • Punti: ${p.score || 0}`}
                                            {currentRoom.gameMode === 'pressure' && !p.isDead && ` • Giri: ${p.laps || 0}`}
                                            {currentRoom.gameMode === 'raid_boss' && (p.uid === currentRoom.hostId ? ` • Boss HP: ${currentRoom.bossHp}` : ` • Vite: ${p.lives}`)}
                                            {currentRoom.gameMode === 'sniper' && p.uid !== currentRoom.sniperUid && ` • Vite: ${p.lives}`}
                                        </div>
                                    </div>
                                    {currentRoom.gameMode === 'raid_boss' && p.uid === currentRoom.bossTargetUid && <Crosshair className="text-red-500 animate-pulse"/>}
                                    {currentRoom.gameMode === 'tiles' && <div className="w-3 h-3 rounded-full" style={{backgroundColor: p.paintColor}}></div>}
                                </div>
                            )})}
                        </div>
                    )}
                </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>